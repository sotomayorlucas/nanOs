%===============================================================================
% NanOS Technical Manual
% A Comprehensive Guide to the Disposable Node Operating System
%===============================================================================

\documentclass[11pt,a4paper,twoside]{book}

%-------------------------------------------------------------------------------
% Packages
%-------------------------------------------------------------------------------
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english,spanish]{babel}
\usepackage{lmodern}
\usepackage{microtype}

% Page layout
\usepackage[margin=2.5cm,inner=3cm,outer=2cm]{geometry}
\usepackage{fancyhdr}
\usepackage{titlesec}

% Graphics and diagrams
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\pgfplotsset{compat=1.18}
\usetikzlibrary{shapes,arrows,positioning,calc,fit,backgrounds,
                decorations.pathreplacing,automata,chains,matrix,
                shapes.geometric,shapes.multipart,patterns,babel}

% Tables and lists
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage{multirow}
\usepackage{enumitem}

% Code listings
\usepackage{listings}
\usepackage{xcolor}

% Math
\usepackage{amsmath}
\usepackage{amssymb}

% Links and references
\usepackage{hyperref}
\usepackage{cleveref}

% Misc
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{framed}
\usepackage{tcolorbox}
\tcbuselibrary{listings,skins,breakable}

%-------------------------------------------------------------------------------
% Color Definitions
%-------------------------------------------------------------------------------
\definecolor{nanosprimary}{RGB}{45,85,140}
\definecolor{nanossecondary}{RGB}{70,130,180}
\definecolor{nanosaccent}{RGB}{220,80,60}
\definecolor{nanosgreen}{RGB}{60,140,80}
\definecolor{nanosgray}{RGB}{100,100,100}
\definecolor{codebg}{RGB}{248,248,248}
\definecolor{codeframe}{RGB}{200,200,200}

%-------------------------------------------------------------------------------
% Code Listing Style
%-------------------------------------------------------------------------------
\lstdefinestyle{nanosC}{
    language=C,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{nanosprimary}\bfseries,
    commentstyle=\color{nanosgreen}\itshape,
    stringstyle=\color{nanosaccent},
    numberstyle=\tiny\color{nanosgray},
    numbers=left,
    numbersep=8pt,
    backgroundcolor=\color{codebg},
    frame=single,
    rulecolor=\color{codeframe},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=4,
    showstringspaces=false,
    captionpos=b,
    morekeywords={uint8_t,uint16_t,uint32_t,uint64_t,int8_t,int16_t,int32_t,
                  bool,size_t,NULL}
}

\lstset{style=nanosC}

%-------------------------------------------------------------------------------
% TikZ Styles
%-------------------------------------------------------------------------------
\tikzstyle{block} = [rectangle, draw, fill=nanosprimary!20,
    text width=5em, text centered, rounded corners, minimum height=3em]
\tikzstyle{node} = [circle, draw, fill=nanossecondary!30,
    minimum size=1.5cm, text centered]
\tikzstyle{queen} = [circle, draw, fill=nanosaccent!40,
    minimum size=2cm, text centered, line width=2pt]
\tikzstyle{arrow} = [thick,->,>=stealth]
\tikzstyle{line} = [thick]
\tikzstyle{packet} = [rectangle, draw, fill=nanosgreen!20,
    minimum width=8cm, minimum height=0.6cm]

%-------------------------------------------------------------------------------
% Header/Footer
%-------------------------------------------------------------------------------
\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE]{\leftmark}
\fancyhead[RO]{\rightmark}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

%-------------------------------------------------------------------------------
% Chapter Style
%-------------------------------------------------------------------------------
\titleformat{\chapter}[display]
{\normalfont\huge\bfseries\color{nanosprimary}}
{\chaptertitlename\ \thechapter}{20pt}{\Huge}

%-------------------------------------------------------------------------------
% Custom Boxes
%-------------------------------------------------------------------------------
\newtcolorbox{infobox}[1][]{
    colback=nanosprimary!5,
    colframe=nanosprimary,
    fonttitle=\bfseries,
    title=#1,
    breakable
}

\newtcolorbox{warningbox}[1][]{
    colback=nanosaccent!5,
    colframe=nanosaccent,
    fonttitle=\bfseries,
    title=#1,
    breakable
}

\newtcolorbox{codebox}[1][]{
    colback=codebg,
    colframe=codeframe,
    fonttitle=\bfseries\ttfamily,
    title=#1,
    breakable
}

%===============================================================================
% Document
%===============================================================================
\begin{document}

%-------------------------------------------------------------------------------
% Title Page
%-------------------------------------------------------------------------------
\begin{titlepage}
\centering
\vspace*{2cm}

% Logo (represented as ASCII art converted to TikZ)
\begin{tikzpicture}[scale=0.8]
    % Hexagonal swarm pattern
    \foreach \i in {0,60,...,300} {
        \node[node, minimum size=1cm, fill=nanossecondary!40]
            at (\i:2cm) {};
    }
    \node[queen, minimum size=1.5cm] at (0,0) {\textbf{Q}};

    % Connections
    \foreach \i in {0,60,...,300} {
        \draw[arrow, nanosprimary!60] (0,0) -- (\i:1.6cm);
    }
    \foreach \i in {0,60,...,300} {
        \pgfmathsetmacro{\nexti}{mod(\i+60,360)}
        \draw[line, nanosgray!40] (\i:2cm) -- (\nexti:2cm);
    }
\end{tikzpicture}

\vspace{1cm}

{\Huge\bfseries\color{nanosprimary} NanOS}\\[0.5cm]
{\Large\color{nanosgray} Nano Operating System for Disposable Nodes}\\[2cm]

{\LARGE\bfseries Manual Técnico}\\[0.5cm]
{\large Versión 0.7}\\[2cm]

\begin{tikzpicture}
    \draw[nanosprimary, line width=2pt] (0,0) -- (10,0);
\end{tikzpicture}

\vspace{1cm}

{\large\textbf{Incluye:}}\\[0.3cm]
{\large Arquitectura del Sistema}\\
{\large Protocolo de Feromonas}\\
{\large NERT: Ephemeral Reliable Transport}\\
{\large Enrutamiento Hebbiano}\\
{\large Stigmergia: Feromonas Digitales}\\
{\large Black Box Distribuida}\\
{\large Hive Bridge: Integración con micrOS}\\
{\large Sintonización Genética (v0.7)}\\
{\large Nodos Judas: Honeypots Activos (v0.7)}\\
{\large Canales Encubiertos (v0.7)}\\
{\large Guía de Implementación}\\[2cm]

\vfill

{\large NanOS Project}\\
{\large Enero 2026}

\end{titlepage}

%-------------------------------------------------------------------------------
% Copyright
%-------------------------------------------------------------------------------
\thispagestyle{empty}
\vspace*{\fill}
\begin{center}
\textbf{NanOS Technical Manual}\\
Version 0.5\\[1cm]

Copyright \textcopyright{} 2026 NanOS Project\\[0.5cm]

Este documento está licenciado bajo MIT License.\\
Se permite la copia, modificación y distribución.\\[1cm]

\textit{``Los nodos mueren, el enjambre vive.''}
\end{center}
\vspace*{\fill}

%-------------------------------------------------------------------------------
% Table of Contents
%-------------------------------------------------------------------------------
\tableofcontents
\listoffigures
\listoftables

%===============================================================================
% PART I: NanOS Core
%===============================================================================
\part{NanOS Core}

%-------------------------------------------------------------------------------
\chapter{Introducción}
%-------------------------------------------------------------------------------

\section{¿Qué es NanOS?}

NanOS es un sistema operativo minimalista diseñado para \textbf{nodos desechables}
en entornos de computación distribuida. A diferencia de los sistemas operativos
tradicionales que buscan estabilidad y persistencia, NanOS abraza la
\textbf{efímera naturaleza} de sus nodos.

\begin{infobox}[Filosofía de Diseño]
\begin{itemize}
    \item \textbf{Sin persistencia}: No hay disco, no hay filesystem. Todo es RAM volátil.
    \item \textbf{Ciclo de vida limitado}: Los nodos tienen muerte programada (apoptosis).
    \item \textbf{Regeneración}: Al morir, renacen con nueva identidad.
    \item \textbf{Inteligencia colectiva}: El comportamiento emerge del enjambre.
\end{itemize}
\end{infobox}

\section{Inspiración Biológica}

NanOS se inspira en sistemas biológicos como colonias de hormigas y organismos
unicelulares. Cada nodo es análogo a una célula que:

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.9]
    % Biological analogy diagram
    \node[draw, rounded corners, fill=nanosgreen!20, minimum width=4cm,
          minimum height=2cm] (cell) at (0,0) {
        \begin{tabular}{c}
            \textbf{Célula}\\
            \small Ciclo de vida finito\\
            \small Apoptosis programada
        \end{tabular}
    };

    \node[draw, rounded corners, fill=nanosprimary!20, minimum width=4cm,
          minimum height=2cm] (node) at (7,0) {
        \begin{tabular}{c}
            \textbf{Nodo NanOS}\\
            \small MAX\_LIFETIME = 1h\\
            \small HEAP\_CRITICAL = 90\%
        \end{tabular}
    };

    \draw[arrow, very thick, nanosaccent] (cell) -- node[above] {Analogía} (node);

    % Pheromone analogy
    \node[draw, rounded corners, fill=nanosgreen!20, minimum width=4cm,
          minimum height=1.5cm] (phero1) at (0,-3.5) {
        \begin{tabular}{c}
            \textbf{Feromonas}\\
            \small Comunicación química
        \end{tabular}
    };

    \node[draw, rounded corners, fill=nanosprimary!20, minimum width=4cm,
          minimum height=1.5cm] (phero2) at (7,-3.5) {
        \begin{tabular}{c}
            \textbf{Pheromone Packets}\\
            \small Broadcast multicast
        \end{tabular}
    };

    \draw[arrow, very thick, nanosaccent] (phero1) -- node[above] {Analogía} (phero2);
\end{tikzpicture}
\caption{Analogía biológica de NanOS}
\label{fig:bio-analogy}
\end{figure}

\section{Plataformas Soportadas}

\begin{table}[H]
\centering
\begin{tabular}{llll}
\toprule
\textbf{Plataforma} & \textbf{Arquitectura} & \textbf{RAM Típica} & \textbf{Uso} \\
\midrule
QEMU x86 & i386/i686 & 128KB--1MB & Desarrollo/Testing \\
ARM Cortex-M3 & ARMv7-M & 64KB & IoT/Embedded \\
ESP32 & Xtensa LX6 & 320KB & WiFi/Low-power \\
ARM64 & ARMv8-A & 1MB+ & Servidores Edge \\
\bottomrule
\end{tabular}
\caption{Plataformas soportadas por NanOS}
\label{tab:platforms}
\end{table}

%-------------------------------------------------------------------------------
\chapter{Arquitectura del Sistema}
%-------------------------------------------------------------------------------

\section{Estructura de Capas}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    layer/.style={draw, minimum width=12cm, minimum height=1.2cm,
                  text centered, font=\small},
    scale=0.9
]
    % Layers from top to bottom
    \node[layer, fill=nanosaccent!20] (app) at (0,5)
        {\textbf{Aplicación} -- Lógica de Rol (Worker, Explorer, Sentinel, Queen)};

    \node[layer, fill=nanosprimary!20] (collective) at (0,3.5)
        {\textbf{Colectivo} -- Elección, Gradiente, Vecinos, KV Store};

    \node[layer, fill=nanossecondary!20] (protocol) at (0,2)
        {\textbf{Protocolo} -- Pheromones, HMAC, Bloom Filter, Gossip};

    \node[layer, fill=nanosgreen!20] (nert) at (0,0.5)
        {\textbf{NERT} -- Transporte Híbrido UDP/TCP};

    \node[layer, fill=nanosgray!20] (hal) at (0,-1)
        {\textbf{HAL} -- Hardware Abstraction Layer};

    \node[layer, fill=nanosgray!40] (hw) at (0,-2.5)
        {\textbf{Hardware} -- e1000, Stellaris ETH, ESP32 WiFi};

    % Arrows
    \foreach \i in {1,...,5} {
        \pgfmathsetmacro{\y}{5 - 1.5*\i + 0.75}
        \pgfmathsetmacro{\ynext}{5 - 1.5*\i - 0.75}
    }

    \draw[arrow] (app.south) -- (collective.north);
    \draw[arrow] (collective.south) -- (protocol.north);
    \draw[arrow] (protocol.south) -- (nert.north);
    \draw[arrow] (nert.south) -- (hal.north);
    \draw[arrow] (hal.south) -- (hw.north);

\end{tikzpicture}
\caption{Arquitectura de capas de NanOS}
\label{fig:layer-arch}
\end{figure}

\section{Componentes del Kernel}

\subsection{Gestión de Memoria}

NanOS utiliza un heap simple sin fragmentación externa mediante allocación
de bloques de tamaño fijo.

\begin{lstlisting}[caption={Constantes de memoria}]
#define HEAP_SIZE           0x10000    /* 64KB heap */
#define HEAP_CRITICAL_PCT   90         /* Muerte si > 90% */
#define BLOCK_SIZE          64         /* Bloques de 64 bytes */
\end{lstlisting}

\subsection{Timer y Scheduling}

El kernel utiliza un timer de sistema (PIT en x86, SysTick en ARM) para:

\begin{itemize}
    \item Mantener el contador de ticks global
    \item Verificar condiciones de apoptosis
    \item Rotar ventanas del Bloom filter
    \item Actualizar timeouts de conexiones
\end{itemize}

\section{Ciclo de Vida del Nodo}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    state/.style={draw, rounded corners, minimum width=2.5cm,
                  minimum height=1cm, text centered},
    scale=0.85
]
    % States
    \node[state, fill=nanosgreen!30] (boot) at (0,0) {BOOT};
    \node[state, fill=nanosprimary!30] (init) at (3,0) {INIT};
    \node[state, fill=nanossecondary!30] (active) at (6,0) {ACTIVE};
    \node[state, fill=nanosaccent!30] (dying) at (9,0) {DYING};
    \node[state, fill=nanosgray!30] (rebirth) at (6,-2.5) {REBIRTH};

    % Transitions
    \draw[arrow] (boot) -- node[above, font=\small] {hal\_init()} (init);
    \draw[arrow] (init) -- node[above, font=\small] {nert\_init()} (active);
    \draw[arrow] (active) -- node[above, font=\small] {apoptosis} (dying);
    \draw[arrow] (dying) -- node[right, font=\small] {emit REBIRTH} (rebirth);
    \draw[arrow] (rebirth) -| node[below, font=\small, pos=0.3] {new ID} (init);

    % Conditions
    \node[font=\scriptsize, text=nanosgray, align=center] at (7.5,0.8)
        {heap $>$ 90\%\\OR\\age $>$ 1h};

\end{tikzpicture}
\caption{Ciclo de vida de un nodo NanOS}
\label{fig:lifecycle}
\end{figure}

\subsection{Condiciones de Apoptosis}

Un nodo entra en estado DYING cuando:

\begin{enumerate}
    \item \textbf{Memoria crítica}: Uso de heap $>$ 90\%
    \item \textbf{Antigüedad}: Tiempo de vida $>$ \texttt{MAX\_CELL\_LIFETIME} (3600s)
    \item \textbf{Comando externo}: Recibe \texttt{PHEROMONE\_DIE} autenticado
\end{enumerate}

%-------------------------------------------------------------------------------
\chapter{Sistema de Roles}
%-------------------------------------------------------------------------------

\section{Roles Definidos}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    role/.style={draw, circle, minimum size=2.5cm, text centered,
                 font=\small, line width=1.5pt},
    scale=0.85
]
    % Queen
    \node[role, fill=nanosaccent!40, draw=nanosaccent] (queen) at (0,0) {
        \begin{tabular}{c}
            \textbf{QUEEN}\\
            \tiny Coordinadora\\
            \tiny Distance = 0
        \end{tabular}
    };

    % Workers
    \node[role, fill=nanosprimary!30, draw=nanosprimary] (w1) at (-3,-3) {
        \begin{tabular}{c}
            \textbf{WORKER}\\
            \tiny Procesamiento\\
            \tiny de tareas
        \end{tabular}
    };

    % Explorer
    \node[role, fill=nanosgreen!30, draw=nanosgreen] (exp) at (3,-3) {
        \begin{tabular}{c}
            \textbf{EXPLORER}\\
            \tiny Descubrimiento\\
            \tiny de terreno
        \end{tabular}
    };

    % Sentinel
    \node[role, fill=nanossecondary!30, draw=nanossecondary] (sent) at (0,-5) {
        \begin{tabular}{c}
            \textbf{SENTINEL}\\
            \tiny Vigilancia\\
            \tiny y alarmas
        \end{tabular}
    };

    % Connections
    \draw[arrow, nanosaccent] (queen) -- node[left, font=\tiny] {CMD} (w1);
    \draw[arrow, nanosaccent] (queen) -- node[right, font=\tiny] {CMD} (exp);
    \draw[arrow, nanosaccent] (queen) -- node[right, font=\tiny] {CMD} (sent);

    \draw[arrow, nanosprimary, dashed] (w1) -- node[below, font=\tiny] {TASK\_DONE} (queen);
    \draw[arrow, nanosgreen, dashed] (exp) -- node[below, font=\tiny] {TERRAIN} (queen);
    \draw[arrow, nanossecondary, dashed] (sent) -- node[left, font=\tiny] {ALARM} (queen);

\end{tikzpicture}
\caption{Sistema de roles en el enjambre}
\label{fig:roles}
\end{figure}

\section{Transición de Roles}

Los nodos pueden cambiar de rol dinámicamente basándose en:

\begin{itemize}
    \item \textbf{Necesidades del enjambre}: Si hay déficit de exploradores,
          workers pueden transicionar
    \item \textbf{Muerte de la reina}: Se inicia proceso de elección
    \item \textbf{Comando de la reina}: Reasignación directa
\end{itemize}

\begin{table}[H]
\centering
\begin{tabular}{lcc}
\toprule
\textbf{Condición} & \textbf{Umbral} & \textbf{Acción} \\
\midrule
Sentinelas $<$ 10\% & MIN\_SENTINEL\_RATIO & Worker $\rightarrow$ Sentinel \\
Exploradores $<$ 10\% & MIN\_EXPLORER\_RATIO & Worker $\rightarrow$ Explorer \\
Sin reina detectada & QUEEN\_TIMEOUT & Iniciar elección \\
\bottomrule
\end{tabular}
\caption{Reglas de transición de roles}
\label{tab:role-transition}
\end{table}

\section{Algoritmo de Elección de Reina}

El algoritmo de elección es \textbf{determinístico} y garantiza convergencia:

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    phase/.style={draw, rounded corners, minimum width=3cm,
                  minimum height=1.5cm, text centered},
    scale=0.9
]
    % Phases
    \node[phase, fill=nanosprimary!20] (detect) at (0,0) {
        \begin{tabular}{c}
            \textbf{Detección}\\
            \small No queen heard\\
            \small for 5s
        \end{tabular}
    };

    \node[phase, fill=nanossecondary!20] (vote) at (5,0) {
        \begin{tabular}{c}
            \textbf{Votación}\\
            \small Broadcast\\
            \small ELECTION
        \end{tabular}
    };

    \node[phase, fill=nanosaccent!20] (count) at (10,0) {
        \begin{tabular}{c}
            \textbf{Conteo}\\
            \small Highest ID\\
            \small wins
        \end{tabular}
    };

    \node[phase, fill=nanosgreen!20] (crown) at (5,-3) {
        \begin{tabular}{c}
            \textbf{Coronación}\\
            \small CORONATION\\
            \small authenticated
        \end{tabular}
    };

    % Arrows
    \draw[arrow] (detect) -- node[above, font=\small] {timeout} (vote);
    \draw[arrow] (vote) -- node[above, font=\small] {5s window} (count);
    \draw[arrow] (count) -- node[right, font=\small] {announce} (crown);
    \draw[arrow, dashed] (crown) -| node[below, font=\small] {cooldown 10s} (detect);

\end{tikzpicture}
\caption{Fases del algoritmo de elección}
\label{fig:election}
\end{figure}

\begin{lstlisting}[caption={Estructura de estado de elección}]
struct election_state {
    uint32_t election_id;      /* ID unico de eleccion */
    uint32_t started_at;       /* Tick de inicio */
    uint32_t my_vote;          /* A quien voto */
    uint32_t highest_vote_id;  /* Maximo ID visto */
    uint8_t  participating;    /* Participando? */
    uint8_t  phase;            /* 0=none, 1=voting, 2=counting */
};
\end{lstlisting}

%-------------------------------------------------------------------------------
\chapter{Protocolo de Feromonas}
%-------------------------------------------------------------------------------

\section{Tipos de Pheromones}

\begin{table}[H]
\centering
\small
\begin{tabular}{clcl}
\toprule
\textbf{Código} & \textbf{Nombre} & \textbf{Auth} & \textbf{Descripción} \\
\midrule
0x01 & HELLO & No & Heartbeat con información de gradiente \\
0x02 & DATA & No & Transporte de datos genérico \\
0x03 & ALARM & No & Alerta de peligro detectado \\
0x04 & ECHO & No & Respuesta/reconocimiento \\
0x05 & ELECTION & No & Voto en elección de reina \\
0x06 & CORONATION & \textbf{Sí} & Anuncio de nueva reina \\
0x10 & QUEEN\_CMD & \textbf{Sí} & Comando de la reina \\
0x20--0x22 & KV\_* & No & Key-Value store distribuido \\
0x30 & TASK & No & Asignación de tarea \\
0x40 & SENSOR & No & Lectura de sensor \\
0x70--0x73 & MAZE\_* & No & Exploración de laberinto \\
0x80--0x87 & TERRAIN\_* & No & Mapeo de terreno \\
0xFE & REBIRTH & \textbf{Sí} & Notificación de muerte/renacimiento \\
0xFF & DIE & \textbf{Sí} & Comando de terminación \\
\midrule
\multicolumn{4}{l}{\textit{Extensiones v0.7}} \\
\midrule
0x14 & CONFIG\_UPDATE & \textbf{Sí} & Actualización de genoma (Genetic Tuning) \\
0x15 & TELEMETRY\_REPORT & No & Reporte de telemetría a Queen \\
0x16 & JUDAS\_ENGAGE & No & Notifica enganche de atacante \\
0x17 & JUDAS\_CAPTURE & No & Payload de atacante capturado \\
0x18 & JUDAS\_FORENSICS & No & BlackBox forense antes de apoptosis \\
\bottomrule
\end{tabular}
\caption{Tipos de pheromones y sus características}
\label{tab:pheromone-types}
\end{table}

\section{Formato de Paquete}

\subsection{Paquete Estándar (64 bytes)}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    field/.style={draw, minimum height=0.8cm, text centered, font=\small},
    scale=0.7
]
    % Header row 1
    \node[field, fill=nanosprimary!20, minimum width=2cm] at (0,0) {magic};
    \node[field, fill=nanosprimary!20, minimum width=2cm] at (2,0) {node\_id};
    \node[field, fill=nanosprimary!20, minimum width=1cm] at (4,0) {type};
    \node[field, fill=nanosprimary!20, minimum width=1cm] at (5,0) {ttl};
    \node[field, fill=nanosprimary!20, minimum width=1cm] at (6,0) {flags};
    \node[field, fill=nanosprimary!20, minimum width=1cm] at (7,0) {ver};

    % Header row 2
    \node[field, fill=nanossecondary!20, minimum width=2cm] at (0,-0.8) {seq};
    \node[field, fill=nanossecondary!20, minimum width=2cm] at (2,-0.8) {dest\_id};
    \node[field, fill=nanossecondary!20, minimum width=1cm] at (4,-0.8) {dist};
    \node[field, fill=nanossecondary!20, minimum width=1cm] at (5,-0.8) {hop};
    \node[field, fill=nanossecondary!20, minimum width=2cm] at (7,-0.8) {via\_node};

    % HMAC
    \node[field, fill=nanosaccent!20, minimum width=4cm] at (1,-1.6) {hmac[8]};
    \node[field, fill=nanosaccent!20, minimum width=4cm] at (5,-1.6) {(cont.)};

    % Payload
    \node[field, fill=nanosgreen!20, minimum width=8cm] at (3,-2.4) {payload[32]};

    % Labels
    \node[font=\scriptsize, anchor=west] at (8.5,0) {Bytes 0--7};
    \node[font=\scriptsize, anchor=west] at (8.5,-0.8) {Bytes 8--15};
    \node[font=\scriptsize, anchor=west] at (8.5,-1.6) {Bytes 16--23};
    \node[font=\scriptsize, anchor=west] at (8.5,-2.4) {Bytes 24--55};

    % Brace for total
    \draw[decorate, decoration={brace, amplitude=10pt, mirror}]
        (-1,-2.8) -- (-1,0.4) node[midway, left=12pt, font=\small] {64 bytes};

\end{tikzpicture}
\caption{Estructura del paquete pheromone estándar}
\label{fig:pheromone-packet}
\end{figure}

\subsection{Paquete Compacto ARM (24 bytes)}

Para plataformas con recursos limitados, se usa un formato compacto con
\textbf{62\% menos overhead}:

\begin{lstlisting}[caption={Estructura del paquete compacto}]
struct nanos_pheromone_compact {
    uint8_t  magic;         /* 0xAA */
    uint16_t node_id;       /* 16-bit truncado */
    uint8_t  type;
    uint8_t  ttl_flags;     /* TTL(4) + flags(4) */
    uint8_t  seq;           /* 8-bit sequence */
    uint16_t dest_id;
    uint8_t  dist_hop;      /* distance(4) + hop(4) */
    uint8_t  payload[8];
    uint8_t  hmac[4];       /* 4-byte truncado */
    uint8_t  reserved[3];
};  /* Total: 24 bytes */
\end{lstlisting}

\section{Autenticación HMAC}

Los paquetes críticos requieren autenticación mediante un HMAC basado en
SipHash simplificado:

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    block/.style={draw, rounded corners, minimum width=2.5cm,
                  minimum height=1cm, text centered, font=\small},
    scale=0.85
]
    % Input
    \node[block, fill=nanosprimary!20] (key) at (0,2) {Swarm Key};
    \node[block, fill=nanossecondary!20] (msg) at (0,0) {Packet Data};

    % SipHash
    \node[block, fill=nanosaccent!20, minimum width=3.5cm] (sip) at (5,1) {
        \begin{tabular}{c}
            \textbf{SipHash-2-4}\\
            \small (simplified)
        \end{tabular}
    };

    % Output
    \node[block, fill=nanosgreen!20] (hmac) at (10,1) {HMAC[8]};

    % Arrows
    \draw[arrow] (key) -| (sip);
    \draw[arrow] (msg) -| (sip);
    \draw[arrow] (sip) -- (hmac);

    % Annotation
    \node[font=\scriptsize, text=nanosgray] at (5,-0.5) {4 rounds mixing};

\end{tikzpicture}
\caption{Proceso de generación de HMAC}
\label{fig:hmac}
\end{figure}

%-------------------------------------------------------------------------------
\chapter{Mecanismos de Red}
%-------------------------------------------------------------------------------

\section{Bloom Filter para Deduplicación}

El Bloom filter proporciona deduplicación $O(1)$ con uso mínimo de memoria:

\begin{lstlisting}[caption={Configuración del Bloom filter}]
#define BLOOM_BITS      256     /* 32 bytes */
#define BLOOM_HASH_K    3       /* 3 funciones hash */
#define BLOOM_SLOTS     4       /* Ventanas rotativas */
#define BLOOM_WINDOW_MS 500     /* 500ms por ventana */
\end{lstlisting}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8]
    % Bloom filter visualization
    \foreach \slot in {0,...,3} {
        \node[font=\small] at (-1.5, -\slot*1.2) {Slot \slot};
        \foreach \bit in {0,...,15} {
            \pgfmathsetmacro{\fill}{random(0,1) > 0.7 ? "nanosprimary!40" : "white"}
            \node[draw, minimum size=0.5cm, fill=\fill]
                at (\bit*0.55, -\slot*1.2) {};
        }
    }

    % Arrow showing rotation
    \draw[arrow, thick, nanosaccent] (9, 0) arc (90:-90:0.6 and 2.4);
    \node[font=\small, nanosaccent] at (10.5, -1.2) {Rotate every 500ms};

    % Labels
    \node[font=\scriptsize] at (4, 1) {256 bits = 32 bytes per slot};

\end{tikzpicture}
\caption{Visualización del Bloom filter con slots rotativos}
\label{fig:bloom}
\end{figure}

\section{Gossip Protocol}

El protocolo de gossip controla la propagación de mensajes para evitar
tormentas de broadcast:

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=2cm,
    every node/.style={font=\small}
]
    % Probability decay graph
    \begin{axis}[
        width=10cm,
        height=6cm,
        xlabel={Copias vistas},
        ylabel={Probabilidad de relay (\%)},
        xmin=0, xmax=10,
        ymin=0, ymax=110,
        grid=major,
        legend pos=north east
    ]

    % Exponential decay: prob = 100 * 0.8^copies
    \addplot[thick, nanosprimary, mark=*] coordinates {
        (0, 100) (1, 80) (2, 64) (3, 51.2) (4, 41)
        (5, 32.8) (6, 26.2) (7, 21) (8, 16.8) (9, 13.4) (10, 10.7)
    };
    \addlegendentry{Probabilidad de relay}

    % Threshold line
    \addplot[dashed, nanosaccent] coordinates {(0, 20) (10, 20)};
    \addlegendentry{Umbral mínimo (20\%)}

    \end{axis}
\end{tikzpicture}
\caption{Decaimiento de probabilidad en el protocolo gossip}
\label{fig:gossip-decay}
\end{figure}

\section{Gradient Routing}

El enrutamiento por gradiente permite dirigir mensajes hacia la reina:

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=1.5cm,
    scale=0.85
]
    % Queen at center
    \node[queen, align=center] (q) at (0,0) {\textbf{Q}\\d=0};

    % Distance 1
    \foreach \i in {0,72,...,288} {
        \node[node, fill=nanosprimary!40] (d1-\i) at (\i:2.5cm) {d=1};
    }

    % Distance 2
    \foreach \i in {36,108,...,324} {
        \node[node, fill=nanossecondary!30, minimum size=1.2cm] (d2-\i) at (\i:4.5cm) {d=2};
    }

    % Connections showing gradient
    \foreach \i in {0,72,...,288} {
        \draw[arrow, nanosprimary!60] (d1-\i) -- (q);
    }

    \foreach \i/\j in {36/0, 108/72, 180/144, 252/216, 324/288} {
        \draw[arrow, nanossecondary!60] (d2-\i) -- (d1-\j);
    }

    % Legend
    \node[anchor=west, font=\small] at (5, 2) {$d$ = distancia a la reina};
    \node[anchor=west, font=\small] at (5, 1.3) {Flechas = dirección del gradiente};

\end{tikzpicture}
\caption{Enrutamiento por gradiente hacia la reina}
\label{fig:gradient}
\end{figure}

\section{Enrutamiento Hebbiano (v0.5)}

La versión 0.5 introduce \textbf{Enrutamiento Hebbiano}, inspirado en la neurociencia:
\textit{``Las neuronas que se disparan juntas, se conectan juntas''}.

\subsection{Peso Sináptico}

Cada conexión con un vecino tiene un \textbf{peso sináptico} $w \in [1, 255]$:

\begin{lstlisting}[caption={Campos de peso sináptico}]
struct neighbor_entry {
    uint32_t node_id;
    uint32_t last_seen;
    uint8_t  role;
    uint8_t  distance;
    uint16_t packets;
    uint8_t  synaptic_weight;  /* v0.5: 0-255, inicial: 128 */
};
\end{lstlisting}

\subsection{Regla de Aprendizaje}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.9]
    % Success path
    \node[draw, rounded corners, fill=nanosgreen!30, minimum width=3cm] (success) at (0,2) {
        \begin{tabular}{c}
            \textbf{Éxito (LTP)}\\
            \small ACK recibido
        \end{tabular}
    };
    \node[font=\large, nanosgreen] at (4,2) {$w \leftarrow \min(255, w + 15)$};

    % Failure path
    \node[draw, rounded corners, fill=nanosaccent!30, minimum width=3cm] (fail) at (0,0) {
        \begin{tabular}{c}
            \textbf{Fallo (LTD)}\\
            \small Timeout/Retries
        \end{tabular}
    };
    \node[font=\large, nanosaccent] at (4,0) {$w \leftarrow \max(1, w - 40)$};

    % STDP bonus
    \node[draw, rounded corners, fill=nanosprimary!20, minimum width=3cm] (stdp) at (0,-2) {
        \begin{tabular}{c}
            \textbf{STDP Bonus}\\
            \small ACK $< 100$ms
        \end{tabular}
    };
    \node[font=\large, nanosprimary] at (4,-2) {$w \leftarrow \min(255, w + 5)$};
\end{tikzpicture}
\caption{Reglas de aprendizaje Hebbiano}
\label{fig:hebbian-rules}
\end{figure}

\begin{warningbox}[Asimetría Castigo/Recompensa]
El castigo ($-40$) es casi 3 veces más severo que la recompensa ($+15$).
Esto asegura que el enjambre aprenda rápidamente a evitar nodos poco confiables.
\end{warningbox}

\subsection{Fórmula de Costo Neural}

El costo de ruta combina distancia y confiabilidad:

\begin{equation}
\text{Costo}(j) = 10 \cdot d_j + \frac{255 - w_j}{8}
\end{equation}

\begin{table}[H]
\centering
\begin{tabular}{ccc}
\toprule
\textbf{Distancia} & \textbf{Peso} & \textbf{Costo} \\
\midrule
1 hop & 255 (perfecto) & $10 + 0 = 10$ \\
1 hop & 128 (neutral) & $10 + 15 = 25$ \\
1 hop & 1 (muerto) & $10 + 31 = 41$ \\
2 hops & 255 (perfecto) & $20 + 0 = 20$ \\
\bottomrule
\end{tabular}
\caption{Ejemplos de cálculo de costo neural}
\label{tab:neural-cost}
\end{table}

\begin{infobox}[Insight Clave]
Una ruta de 2 saltos confiable (costo 20) es mejor que una ruta de 1 salto
poco confiable (costo 41). El enjambre \textbf{aprende a rodear} nodos problemáticos.
\end{infobox}

%-------------------------------------------------------------------------------
\chapter{Stigmergia: Feromonas Digitales (v0.5)}
%-------------------------------------------------------------------------------

\section{Inspiración Biológica}

Las hormigas no memorizan mapas; dejan \textbf{químicos que se evaporan}. Este
mecanismo de coordinación indirecta a través de modificación del ambiente se
llama \textbf{stigmergia}. NanOS v0.5 implementa este concepto digitalmente.

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.9]
    % Biological analogy
    \node[draw, rounded corners, fill=nanosgreen!20, minimum width=4cm,
          minimum height=2.5cm] (bio) at (0,0) {
        \begin{tabular}{c}
            \textbf{Hormigas}\\
            \small Feromona química\\
            \small Se evapora con el tiempo\\
            \small Atrae o repele
        \end{tabular}
    };

    \node[draw, rounded corners, fill=nanosprimary!20, minimum width=4cm,
          minimum height=2.5cm] (digital) at (7,0) {
        \begin{tabular}{c}
            \textbf{NanOS Stigmergia}\\
            \small Feromona digital (4 bits)\\
            \small Decae 1/segundo\\
            \small Modifica costo de ruta
        \end{tabular}
    };

    \draw[arrow, very thick, nanosaccent] (bio) -- node[above] {Analogía} (digital);
\end{tikzpicture}
\caption{Analogía biológica de Stigmergia}
\label{fig:stigmergia-bio}
\end{figure}

\section{Tipos de Feromonas}

\begin{table}[H]
\centering
\begin{tabular}{clcp{5cm}}
\toprule
\textbf{Código} & \textbf{Tipo} & \textbf{Efecto} & \textbf{Uso} \\
\midrule
0 & DANGER & Repulsión (+8/nivel) & Jamming, ataques, nodos maliciosos \\
1 & QUEEN & Atracción (-2/nivel) & Camino hacia la reina \\
2 & RESOURCE & Neutral & Marcador de objetivos \\
3 & AVOID & Repulsión (+4/nivel) & Zonas subóptimas (no peligrosas) \\
\bottomrule
\end{tabular}
\caption{Tipos de feromonas digitales}
\label{tab:pheromone-types-stig}
\end{table}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.9]
    % Pheromone type icons
    \node[draw, circle, fill=nanosaccent!60, minimum size=2cm, align=center] (danger) at (0,0) {
        \textbf{DANGER}\\
        \tiny Repulsión
    };
    \node[draw, circle, fill=nanosgreen!50, minimum size=2cm, align=center] (queen) at (4,0) {
        \textbf{QUEEN}\\
        \tiny Atracción
    };
    \node[draw, circle, fill=nanosprimary!40, minimum size=2cm, align=center] (resource) at (8,0) {
        \textbf{RESOURCE}\\
        \tiny Neutro
    };
    \node[draw, circle, fill=nanosgray!40, minimum size=2cm, align=center] (avoid) at (12,0) {
        \textbf{AVOID}\\
        \tiny Repulsión
    };

    % Effect arrows
    \draw[<-,very thick,nanosaccent] (danger.south) -- ++(0,-1.5) node[below,font=\small] {+8/nivel};
    \draw[->,very thick,nanosgreen] (queen.south) -- ++(0,-1.5) node[below,font=\small] {-2/nivel};
    \node[below=1.5cm of resource,font=\small] {0};
    \draw[<-,very thick,nanosgray] (avoid.south) -- ++(0,-1.5) node[below,font=\small] {+4/nivel};

    % Labels
    \node[font=\tiny] at (0,-3.5) {Jamming, ataques};
    \node[font=\tiny] at (4,-3.5) {Rastro a reina};
    \node[font=\tiny] at (8,-3.5) {Objetivos};
    \node[font=\tiny] at (12,-3.5) {Subóptimo};
\end{tikzpicture}
\caption{Tipos de feromonas y su efecto en el costo de movimiento}
\label{fig:pheromone-types-visual}
\end{figure}

\section{Estructura de Datos}

\begin{lstlisting}[caption={Almacenamiento de feromonas}]
/* Cada celda almacena 4 tipos en 2 bytes (nibble packing) */
struct stigmergia_cell {
    uint8_t data[2];  /* [danger|queen], [resource|avoid] */
};

/* Grid 16x16 cubriendo terreno 32x32 (escala 2:1) */
struct stigmergia_cell pheromones[16][16];  /* 512 bytes total */

/* Acceso a intensidad (0-15) */
uint8_t stigmergia_get(uint8_t x, uint8_t y, uint8_t type);
void stigmergia_mark(uint8_t x, uint8_t y, uint8_t type, uint8_t intensity);
\end{lstlisting}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.7]
    % Byte 0
    \node[font=\small\bfseries] at (-2, 1.5) {Byte 0:};
    \draw[fill=nanosaccent!40] (0,1) rectangle (2,2);
    \draw[fill=nanosgreen!40] (2,1) rectangle (4,2);
    \node at (1, 1.5) {\small DANGER};
    \node at (3, 1.5) {\small QUEEN};

    % Byte 1
    \node[font=\small\bfseries] at (-2, -0.5) {Byte 1:};
    \draw[fill=nanosprimary!40] (0,-1) rectangle (2,0);
    \draw[fill=nanosgray!40] (2,-1) rectangle (4,0);
    \node at (1, -0.5) {\small RESOURCE};
    \node at (3, -0.5) {\small AVOID};

    % Bit markers
    \foreach \x/\bit in {0/7, 0.5/6, 1/5, 1.5/4, 2/3, 2.5/2, 3/1, 3.5/0} {
        \node[font=\tiny, above] at (\x+0.25, 2) {\bit};
    }

    % Nibble brackets
    \draw[decorate, decoration={brace, amplitude=5pt}] (0,2.3) -- (2,2.3)
        node[midway, above=5pt, font=\tiny] {4 bits (0-15)};
    \draw[decorate, decoration={brace, amplitude=5pt}] (2,2.3) -- (4,2.3)
        node[midway, above=5pt, font=\tiny] {4 bits (0-15)};

    % Total annotation
    \draw[decorate, decoration={brace, amplitude=8pt, mirror}] (4.2,2) -- (4.2,-1)
        node[midway, right=10pt, font=\small, align=left] {2 bytes\\por celda};

    % Grid visualization
    \node[font=\small\bfseries] at (8, 1.5) {Grid 16×16:};
    \draw[step=0.3, gray!50] (6,-1) grid (9.8,2.8);
    \draw[thick] (6,-1) rectangle (9.8,2.8);

    % Annotation
    \node[font=\tiny, align=center] at (7.9, -1.8) {16 × 16 × 2 bytes\\= 512 bytes total};
\end{tikzpicture}
\caption{Nibble packing: 4 tipos de feromona en 2 bytes por celda}
\label{fig:nibble-packing}
\end{figure}

\section{Decaimiento Temporal}

\begin{figure}[H]
\centering
\begin{tikzpicture}
    \begin{axis}[
        width=12cm,
        height=6cm,
        xlabel={Tiempo (segundos)},
        ylabel={Intensidad de feromona},
        xmin=0, xmax=20,
        ymin=0, ymax=17,
        grid=major,
        legend pos=north east
    ]

    % Decay from max (15)
    \addplot[thick, nanosaccent, mark=*] coordinates {
        (0, 15) (1, 14) (2, 13) (3, 12) (4, 11) (5, 10)
        (6, 9) (7, 8) (8, 7) (9, 6) (10, 5) (11, 4)
        (12, 3) (13, 2) (14, 1) (15, 0) (16, 0) (17, 0)
    };
    \addlegendentry{Intensidad inicial = 15}

    % Decay from medium (8)
    \addplot[thick, nanosprimary, mark=square*] coordinates {
        (0, 8) (1, 7) (2, 6) (3, 5) (4, 4) (5, 3)
        (6, 2) (7, 1) (8, 0) (9, 0) (10, 0)
    };
    \addlegendentry{Intensidad inicial = 8}

    % Propagation threshold
    \addplot[dashed, nanosgreen] coordinates {(0, 6) (20, 6)};
    \addlegendentry{Umbral de propagación}

    \end{axis}
\end{tikzpicture}
\caption{Decaimiento de feromonas: -1 cada segundo}
\label{fig:pheromone-decay}
\end{figure}

\begin{warningbox}[Evaporación]
La feromona \textbf{se pierde} si no es reforzada. Un peligro detectado hace
15 segundos ya no existe en el mapa. Esto evita información obsoleta.
\end{warningbox}

\section{Modificación de Costo de Movimiento}

La presencia de feromonas modifica el costo de moverse a una celda:

\begin{equation}
\text{Costo}_{\text{total}} = \text{Costo}_{\text{base}} + 8 \cdot I_{\text{DANGER}} + 4 \cdot I_{\text{AVOID}} - 2 \cdot I_{\text{QUEEN}}
\end{equation}

\begin{table}[H]
\centering
\begin{tabular}{lccc}
\toprule
\textbf{Situación} & \textbf{Feromonas} & \textbf{Modificador} & \textbf{Costo Final} \\
\midrule
Celda normal & Ninguna & 0 & 10 \\
Zona peligrosa & DANGER=15 & +120 & 130 \\
Cerca de reina & QUEEN=10 & -20 & -10 (atracción) \\
Zona subóptima & AVOID=8 & +32 & 42 \\
Mixta & DANGER=5, QUEEN=3 & +40-6=+34 & 44 \\
\bottomrule
\end{tabular}
\caption{Ejemplos de modificación de costo}
\label{tab:cost-mod}
\end{table}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.65]
    % Grid background
    \foreach \x in {0,...,7} {
        \foreach \y in {0,...,5} {
            \fill[white] (\x*1.2,\y*1.2) rectangle (\x*1.2+1.1,\y*1.2+1.1);
            \draw[gray!30] (\x*1.2,\y*1.2) rectangle (\x*1.2+1.1,\y*1.2+1.1);
        }
    }

    % Danger zone (red gradient)
    \fill[nanosaccent!80] (3.6,2.4) rectangle (4.7,3.5);
    \fill[nanosaccent!60] (2.4,2.4) rectangle (3.5,3.5);
    \fill[nanosaccent!60] (4.8,2.4) rectangle (5.9,3.5);
    \fill[nanosaccent!40] (3.6,1.2) rectangle (4.7,2.3);
    \fill[nanosaccent!40] (3.6,3.6) rectangle (4.7,4.7);
    \node[white, font=\tiny\bfseries] at (4.15, 2.95) {DANGER};
    \node[font=\tiny] at (4.15, 2.55) {130};

    % Queen attraction zone (green)
    \fill[nanosgreen!60] (7.2,4.8) rectangle (8.3,5.9);
    \fill[nanosgreen!40] (6,4.8) rectangle (7.1,5.9);
    \fill[nanosgreen!40] (7.2,3.6) rectangle (8.3,4.7);
    \node[font=\tiny\bfseries] at (7.75, 5.35) {QUEEN};

    % Start and End nodes
    \node[draw, circle, fill=nanosprimary!60, minimum size=0.8cm] (start) at (0.55, 0.55) {S};
    \node[draw, circle, fill=nanosgreen!60, minimum size=0.8cm] (end) at (7.75, 5.35) {Q};

    % Path 1: Direct (through danger) - BAD
    \draw[dashed, nanosaccent, very thick] (0.55, 0.55) -- (4.15, 2.95);
    \draw[dashed, nanosaccent, very thick] (4.15, 2.95) -- (7.75, 5.35);
    \node[nanosaccent, font=\tiny, align=center] at (2.5, 2.5) {Ruta directa\\Costo: 250+};

    % Path 2: Around danger - GOOD
    \draw[very thick, nanosgreen!80!black, ->] (0.55, 0.55) -- (1.75, 0.55) -- (1.75, 4.75) -- (7.75, 5.35);
    \node[nanosgreen!80!black, font=\tiny, align=center] at (1, 3.5) {Ruta segura\\Costo: 80};

    % Legend
    \node[draw, fill=nanosaccent!60, minimum width=0.5cm, minimum height=0.3cm] at (10, 5) {};
    \node[right, font=\tiny] at (10.4, 5) {DANGER (alto costo)};
    \node[draw, fill=nanosgreen!50, minimum width=0.5cm, minimum height=0.3cm] at (10, 4.3) {};
    \node[right, font=\tiny] at (10.4, 4.3) {QUEEN (atracción)};
    \draw[nanosgreen!80!black, very thick, ->] (9.8, 3.6) -- (10.3, 3.6);
    \node[right, font=\tiny] at (10.4, 3.6) {Ruta óptima};
\end{tikzpicture}
\caption{Efecto de feromonas en pathfinding: el enjambre rodea zonas peligrosas}
\label{fig:pathfinding-stigmergia}
\end{figure}

\section{Propagación de Feromonas}

Las feromonas de alta intensidad se propagan a celdas vecinas:

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8]
    % Center cell (source)
    \node[draw, fill=nanosaccent!60, minimum size=1.5cm] (center) at (0,0) {\textbf{15}};

    % Adjacent cells (propagated)
    \node[draw, fill=nanosaccent!40, minimum size=1.5cm] at (2,0) {12};
    \node[draw, fill=nanosaccent!40, minimum size=1.5cm] at (-2,0) {12};
    \node[draw, fill=nanosaccent!40, minimum size=1.5cm] at (0,2) {12};
    \node[draw, fill=nanosaccent!40, minimum size=1.5cm] at (0,-2) {12};

    % Diagonal cells (weaker)
    \node[draw, fill=nanosaccent!20, minimum size=1.5cm] at (2,2) {9};
    \node[draw, fill=nanosaccent!20, minimum size=1.5cm] at (-2,2) {9};
    \node[draw, fill=nanosaccent!20, minimum size=1.5cm] at (2,-2) {9};
    \node[draw, fill=nanosaccent!20, minimum size=1.5cm] at (-2,-2) {9};

    % Arrows
    \draw[arrow, nanosaccent] (0.8,0) -- (1.2,0);
    \draw[arrow, nanosaccent] (-0.8,0) -- (-1.2,0);
    \draw[arrow, nanosaccent] (0,0.8) -- (0,1.2);
    \draw[arrow, nanosaccent] (0,-0.8) -- (0,-1.2);

    % Legend
    \node[font=\small, anchor=west] at (4,1) {Intensidad original: 15};
    \node[font=\small, anchor=west] at (4,0) {Propagación: -3 por salto};
    \node[font=\small, anchor=west] at (4,-1) {Umbral mínimo: 6};

\end{tikzpicture}
\caption{Propagación de feromona DANGER}
\label{fig:propagation}
\end{figure}

\section{API de Stigmergia}

\begin{lstlisting}[caption={Funciones principales de Stigmergia}]
/* Inicializar sistema (limpia todas las feromonas) */
void stigmergia_init(void);

/* Marcar feromona en coordenadas de terreno */
void stigmergia_mark(uint8_t terrain_x, uint8_t terrain_y,
                     uint8_t type, uint8_t intensity);

/* Obtener intensidad en coordenadas */
uint8_t stigmergia_get(uint8_t terrain_x, uint8_t terrain_y,
                       uint8_t type);

/* Aplicar decaimiento (llamar cada segundo) */
void stigmergia_decay(void);

/* Calcular modificador de costo para pathfinding */
int8_t stigmergia_cost_modifier(uint8_t terrain_x, uint8_t terrain_y);

/* Emitir feromona de peligro (convenience) */
void stigmergia_emit_danger(uint8_t intensity);

/* Emitir rastro hacia la reina */
void stigmergia_emit_queen_trail(void);
\end{lstlisting}

%-------------------------------------------------------------------------------
\chapter{Black Box Distribuida: ``El Último Aliento'' (v0.5)}
%-------------------------------------------------------------------------------

\section{Problema: Evidencia Forense Perdida}

Cuando un nodo es comprometido y terminado, su evidencia forense se pierde.
Un atacante inteligente podría:

\begin{enumerate}
    \item Comprometer un nodo
    \item Extraer información sensible
    \item Forzar su ``suicidio'' para eliminar rastros
\end{enumerate}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8]
    % Timeline
    \draw[->, thick] (0,0) -- (14,0) node[right, font=\small] {tiempo};

    % Attack phases
    \fill[nanosprimary!30] (0,-0.5) rectangle (3,0.5);
    \fill[nanosaccent!30] (3,-0.5) rectangle (7,0.5);
    \fill[nanosaccent!60] (7,-0.5) rectangle (10,0.5);
    \fill[nanosgray!40] (10,-0.5) rectangle (13,0.5);

    % Phase labels
    \node[font=\tiny, align=center] at (1.5, 0) {Nodo\\operando};
    \node[font=\tiny, align=center] at (5, 0) {Nodo\\comprometido};
    \node[font=\tiny, align=center] at (8.5, 0) {Atacante\\extrae data};
    \node[font=\tiny, align=center] at (11.5, 0) {Nodo\\``suicidado''};

    % Events below timeline
    \node[font=\tiny, nanosaccent] at (3, -1.2) {Ataque};
    \draw[->, nanosaccent] (3, -1) -- (3, -0.6);

    \node[font=\tiny, nanosaccent] at (10, -1.2) {Eliminación};
    \draw[->, nanosaccent] (10, -1) -- (10, -0.6);

    % Without Black Box
    \node[font=\small\bfseries, nanosaccent] at (7, -2.5) {SIN Black Box:};
    \node[font=\tiny, align=center] at (7, -3.2) {Evidencia perdida para siempre\\El enjambre no sabe qué pasó};

    % Evidence icon (crossed out)
    \node[draw, fill=nanosgray!20, minimum size=0.8cm] at (11.5, -2.8) {\tiny Logs};
    \draw[nanosaccent, very thick] (11, -2.3) -- (12, -3.3);
    \draw[nanosaccent, very thick] (11, -3.3) -- (12, -2.3);
\end{tikzpicture}
\caption{Escenario de ataque sin Black Box: la evidencia se pierde al morir el nodo}
\label{fig:attack-timeline}
\end{figure}

\begin{warningbox}[Escenario de Ataque]
Sin Black Box: El atacante elimina el nodo y toda evidencia de compromiso
desaparece. El enjambre no sabe qué pasó.
\end{warningbox}

\section{Solución: El Último Aliento}

Antes de morir, cada nodo transmite un ``testamento'' (Last Will) a vecinos
de confianza. Incluso si el nodo fue hackeado y suicidado, su evidencia
sobrevive en el enjambre.

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.7]
    % WITHOUT Black Box
    \node[font=\small\bfseries, nanosaccent] at (3, 3.5) {SIN Black Box};

    % Timeline without
    \draw[->, thick] (0, 2) -- (6, 2);
    \fill[nanosaccent!30] (3, 1.5) rectangle (4.5, 2.5);
    \node[font=\tiny] at (3.75, 2) {Ataque};
    \fill[nanosgray!50] (4.5, 1.5) rectangle (6, 2.5);
    \node[font=\tiny] at (5.25, 2) {Muerte};

    % Evidence lost
    \node[draw, fill=nanosaccent!20, rounded corners, font=\tiny] at (3, 0.5) {Evidencia};
    \draw[nanosaccent, very thick] (2.5, 0) -- (3.5, 1);
    \draw[nanosaccent, very thick] (2.5, 1) -- (3.5, 0);
    \node[font=\tiny, nanosaccent] at (3, -0.3) {PERDIDA};

    % WITH Black Box
    \node[font=\small\bfseries, nanosgreen!80!black] at (11, 3.5) {CON Black Box};

    % Timeline with
    \draw[->, thick] (8, 2) -- (14, 2);
    \fill[nanosaccent!30] (11, 1.5) rectangle (12.5, 2.5);
    \node[font=\tiny] at (11.75, 2) {Ataque};
    \fill[nanosgray!50] (12.5, 1.5) rectangle (14, 2.5);
    \node[font=\tiny] at (13.25, 2) {Muerte};

    % Evidence transmitted
    \node[draw, fill=nanosgreen!30, rounded corners, font=\tiny] at (11, 0.5) {Evidencia};
    \draw[->, very thick, nanosgreen!80!black] (11.6, 0.5) -- (12.8, 0.5);
    \draw[->, very thick, nanosgreen!80!black] (11.6, 0.7) -- (12.8, 1.2);
    \draw[->, very thick, nanosgreen!80!black] (11.6, 0.3) -- (12.8, -0.2);

    % Survivors
    \node[draw, circle, fill=nanosgreen!40, minimum size=0.6cm, font=\tiny] at (13.5, 0.5) {T1};
    \node[draw, circle, fill=nanosgreen!40, minimum size=0.6cm, font=\tiny] at (13.5, 1.2) {T2};
    \node[draw, circle, fill=nanosgreen!40, minimum size=0.6cm, font=\tiny] at (13.5, -0.2) {T3};
    \node[font=\tiny, nanosgreen!80!black] at (13.5, -0.9) {SOBREVIVE};

    % Comparison arrow
    \draw[->, very thick, double] (6.5, 1) -- (7.5, 1);
    \node[font=\tiny, above] at (7, 1) {vs};
\end{tikzpicture}
\caption{Comparación: sin Black Box la evidencia se pierde, con Black Box sobrevive}
\label{fig:blackbox-comparison}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node/.style={draw, circle, minimum size=1.5cm, text centered, font=\small},
    scale=0.85
]
    % Dying node
    \node[node, fill=nanosaccent!50, line width=2pt] (dying) at (0,0) {
        \begin{tabular}{c}
            \textbf{Dying}\\
            \tiny Node
        \end{tabular}
    };

    % Trusted neighbors
    \node[node, fill=nanosgreen!40] (t1) at (4,2) {
        \begin{tabular}{c}
            T1\\
            \tiny w=240
        \end{tabular}
    };
    \node[node, fill=nanosgreen!40] (t2) at (4,0) {
        \begin{tabular}{c}
            T2\\
            \tiny w=220
        \end{tabular}
    };
    \node[node, fill=nanosgreen!40] (t3) at (4,-2) {
        \begin{tabular}{c}
            T3\\
            \tiny w=200
        \end{tabular}
    };

    % Untrusted neighbor (not selected)
    \node[node, fill=nanosgray!30, dashed] (u1) at (-3,1.5) {
        \begin{tabular}{c}
            U1\\
            \tiny w=50
        \end{tabular}
    };

    % Last Will transmission
    \draw[arrow, very thick, nanosaccent] (dying) -- node[above, font=\scriptsize] {Last Will} (t1);
    \draw[arrow, very thick, nanosaccent] (dying) -- node[above, font=\scriptsize] {Last Will} (t2);
    \draw[arrow, very thick, nanosaccent] (dying) -- node[below, font=\scriptsize] {Last Will} (t3);

    % No transmission to untrusted
    \draw[dashed, nanosgray] (dying) -- (u1);
    \node[font=\tiny, nanosgray] at (-1.8,1.2) {No enviado};

    % Legend
    \node[font=\small, anchor=west] at (6,2) {Testamento enviado a};
    \node[font=\small, anchor=west] at (6,1.5) {vecinos con mayor};
    \node[font=\small, anchor=west] at (6,1) {peso Hebbiano};

\end{tikzpicture}
\caption{Transmisión del Último Aliento a vecinos de confianza}
\label{fig:last-will}
\end{figure}

\section{Contenido del Testamento}

\begin{lstlisting}[caption={Estructura del Last Will}]
/* Razones de muerte */
#define DEATH_NATURAL           0x00  /* Vejez/timeout normal */
#define DEATH_HEAP_EXHAUSTED    0x01  /* Sin memoria */
#define DEATH_CORRUPTION        0x02  /* Corrupcion detectada */
#define DEATH_ATTACK_DETECTED   0x03  /* Ataque en progreso */
#define DEATH_QUEEN_ORDER       0x04  /* Orden de la reina */
#define DEATH_ISOLATION         0x05  /* Sin contacto con enjambre */

/* Tipos de eventos de seguridad */
#define EVENT_BAD_MAC           0x01  /* MAC invalido recibido */
#define EVENT_REPLAY            0x02  /* Intento de replay */
#define EVENT_RATE_LIMIT        0x03  /* Rate limit excedido */
#define EVENT_BLACKLIST         0x04  /* Nodo en blacklist */
#define EVENT_JAMMING           0x05  /* Jamming detectado */
#define EVENT_CORRUPTION        0x06  /* Corrupcion de memoria */

/* Contenido del testamento */
struct last_will {
    uint32_t node_id;           /* ID del nodo que muere */
    uint8_t  death_reason;      /* DEATH_* codigo */
    uint8_t  uptime_hours;      /* Horas de vida */
    uint16_t bad_mac_count;     /* MACs invalidos recibidos */
    uint16_t replay_count;      /* Intentos de replay */
    uint16_t rate_limit_hits;   /* Veces rate limited */

    /* Ultimos 8 eventos de seguridad */
    struct {
        uint8_t  type;          /* EVENT_* tipo */
        uint16_t source_node;   /* Nodo relacionado */
        uint32_t timestamp;     /* Cuando ocurrio */
    } events[8];
};
\end{lstlisting}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.75]
    % Death reasons column
    \node[font=\small\bfseries] at (2, 4.5) {Razones de Muerte};

    \node[draw, rounded corners, fill=nanosgreen!30, minimum width=3.5cm, minimum height=0.7cm]
        at (2, 3.5) {\small NATURAL (0x00)};
    \node[draw, rounded corners, fill=nanosprimary!30, minimum width=3.5cm, minimum height=0.7cm]
        at (2, 2.5) {\small HEAP\_EXHAUSTED};
    \node[draw, rounded corners, fill=nanosaccent!30, minimum width=3.5cm, minimum height=0.7cm]
        at (2, 1.5) {\small CORRUPTION};
    \node[draw, rounded corners, fill=nanosaccent!50, minimum width=3.5cm, minimum height=0.7cm]
        at (2, 0.5) {\small ATTACK\_DETECTED};
    \node[draw, rounded corners, fill=nanossecondary!30, minimum width=3.5cm, minimum height=0.7cm]
        at (2, -0.5) {\small QUEEN\_ORDER};
    \node[draw, rounded corners, fill=nanosgray!30, minimum width=3.5cm, minimum height=0.7cm]
        at (2, -1.5) {\small ISOLATION};

    % Severity indicator
    \draw[->, very thick, nanosaccent] (4.5, 3.5) -- (4.5, -1.5);
    \node[font=\tiny, rotate=90] at (5, 1) {Severidad};

    % Security events column
    \node[font=\small\bfseries] at (9, 4.5) {Eventos de Seguridad};

    \node[draw, rounded corners, fill=nanosaccent!20, minimum width=3cm, minimum height=0.6cm]
        at (9, 3.5) {\small BAD\_MAC};
    \node[draw, rounded corners, fill=nanosaccent!30, minimum width=3cm, minimum height=0.6cm]
        at (9, 2.7) {\small REPLAY};
    \node[draw, rounded corners, fill=nanosaccent!40, minimum width=3cm, minimum height=0.6cm]
        at (9, 1.9) {\small RATE\_LIMIT};
    \node[draw, rounded corners, fill=nanosaccent!50, minimum width=3cm, minimum height=0.6cm]
        at (9, 1.1) {\small BLACKLIST};
    \node[draw, rounded corners, fill=nanosaccent!60, minimum width=3cm, minimum height=0.6cm]
        at (9, 0.3) {\small JAMMING};
    \node[draw, rounded corners, fill=nanosaccent!70, minimum width=3cm, minimum height=0.6cm]
        at (9, -0.5) {\small CORRUPTION};

    % Connection
    \draw[->, thick, nanosgray] (5.5, 1) -- (6.8, 1);
    \node[font=\tiny, above] at (6.15, 1) {registra};
\end{tikzpicture}
\caption{Códigos de muerte y eventos de seguridad registrados en el testamento}
\label{fig:death-reasons-visual}
\end{figure}

\section{Flujo de Operación}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    phase/.style={draw, rounded corners, minimum width=3cm,
                  minimum height=1.5cm, text centered, font=\small},
    scale=0.8
]
    % Phases
    \node[phase, fill=nanosprimary!20] (record) at (0,0) {
        \begin{tabular}{c}
            \textbf{Registro}\\
            \small blackbox\_record\_event()\\
            \small durante operación
        \end{tabular}
    };

    \node[phase, fill=nanosaccent!20] (trigger) at (5.5,0) {
        \begin{tabular}{c}
            \textbf{Trigger}\\
            \small cell\_apoptosis()\\
            \small detecta muerte
        \end{tabular}
    };

    \node[phase, fill=nanosgreen!20] (emit) at (11,0) {
        \begin{tabular}{c}
            \textbf{Emisión}\\
            \small blackbox\_emit\_last\_will()\\
            \small a vecinos confiables
        \end{tabular}
    };

    \node[phase, fill=nanossecondary!20] (store) at (5.5,-3) {
        \begin{tabular}{c}
            \textbf{Almacenamiento}\\
            \small blackbox\_process\_last\_will()\\
            \small en receptores
        \end{tabular}
    };

    % Arrows
    \draw[arrow] (record) -- (trigger);
    \draw[arrow] (trigger) -- (emit);
    \draw[arrow] (emit) |- (store);

    % Death
    \node[font=\scriptsize, nanosaccent] at (8,-1.5) {Nodo muere};

\end{tikzpicture}
\caption{Flujo del sistema Black Box}
\label{fig:blackbox-flow}
\end{figure}

\section{Almacenamiento de Testamentos}

Cada nodo almacena hasta 8 testamentos recibidos:

\begin{lstlisting}[caption={Almacenamiento de testamentos}]
#define BLACKBOX_MAX_WILLS  8

/* Estructura de almacenamiento */
struct blackbox_storage {
    struct {
        uint32_t node_id;
        uint8_t  death_reason;
        uint8_t  uptime_hours;
        uint16_t bad_mac_count;
        uint16_t replay_count;
        uint8_t  priority;      /* Para relay y reemplazo */
        uint8_t  event_count;
    } wills[BLACKBOX_MAX_WILLS];

    uint8_t count;              /* Testamentos almacenados */
};
\end{lstlisting}

\section{API de Black Box}

\begin{lstlisting}[caption={Funciones principales de Black Box}]
/* Inicializar sistema */
void blackbox_init(void);

/* Registrar evento de seguridad (durante operacion) */
void blackbox_record_event(uint8_t event_type, uint16_t source_node);

/* Emitir testamento antes de morir */
void blackbox_emit_last_will(uint8_t death_reason);

/* Procesar testamento recibido */
void blackbox_process_last_will(struct nanos_pheromone* pkt);

/* Consultar muerte de un nodo */
int blackbox_query_death(uint32_t node_id,
                         uint8_t *death_reason,
                         uint16_t *bad_mac_count,
                         uint8_t *uptime_hours);

/* Obtener numero de testamentos almacenados */
uint8_t blackbox_get_will_count(void);

/* Propagar testamentos criticos a vecinos */
void blackbox_relay_critical(void);

/* Imprimir resumen forense (debug) */
void blackbox_print_summary(void);
\end{lstlisting}

\section{Ejemplo de Investigación Forense}

\begin{lstlisting}[caption={Consulta forense de nodo muerto}]
void investigate_dead_node(uint32_t suspect_id) {
    uint8_t death_reason;
    uint16_t bad_mac;
    uint8_t uptime;

    if (blackbox_query_death(suspect_id, &death_reason,
                             &bad_mac, &uptime) == 0) {
        printf("Node 0x%08x death investigation:\n", suspect_id);
        printf("  Uptime: %d hours\n", uptime);

        switch (death_reason) {
            case DEATH_ATTACK_DETECTED:
                printf("  ALERT: Died under attack!\n");
                printf("  Bad MACs received: %d\n", bad_mac);
                break;
            case DEATH_CORRUPTION:
                printf("  Memory corruption detected\n");
                break;
            case DEATH_NATURAL:
                printf("  Normal lifecycle end\n");
                break;
        }
    } else {
        printf("No forensic data for node 0x%08x\n", suspect_id);
    }
}
\end{lstlisting}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8]
    % Title
    \node[font=\small\bfseries] at (6, 4) {Probabilidad de Supervivencia de Evidencia};

    % Dying node
    \node[draw, circle, fill=nanosaccent!50, minimum size=1.2cm] (dying) at (0, 1.5) {\tiny Dying};

    % Recipients (k=3)
    \node[draw, circle, fill=nanosgreen!40, minimum size=1cm] (r1) at (3, 3) {\tiny R1};
    \node[draw, circle, fill=nanosgreen!40, minimum size=1cm] (r2) at (3, 1.5) {\tiny R2};
    \node[draw, circle, fill=nanosgreen!40, minimum size=1cm] (r3) at (3, 0) {\tiny R3};

    % Arrows with labels
    \draw[->, thick] (dying) -- (r1);
    \draw[->, thick] (dying) -- (r2);
    \draw[->, thick] (dying) -- (r3);

    % Probability annotations
    \node[font=\tiny, right] at (3.6, 3) {$p_{comp} = 10\%$};
    \node[font=\tiny, right] at (3.6, 1.5) {$p_{comp} = 10\%$};
    \node[font=\tiny, right] at (3.6, 0) {$p_{comp} = 10\%$};

    % Formula box
    \node[draw, rounded corners, fill=nanosprimary!10, minimum width=5cm, minimum height=2.5cm, align=center]
        at (9, 1.5) {
        \begin{tabular}{c}
            $P(\text{pérdida total}) = p^k = 0.1^3$\\[0.3cm]
            $= 0.001 = 0.1\%$\\[0.3cm]
            \textcolor{nanosgreen}{\textbf{$P(\text{sobrevive}) = 99.9\%$}}
        \end{tabular}
    };

    % Bar chart comparison
    \node[font=\tiny\bfseries] at (6, -1.5) {Comparación por número de receptores};

    % k=1
    \fill[nanosaccent!60] (3.5, -2) rectangle (4, -2.9);
    \node[font=\tiny, below] at (3.75, -3) {k=1};
    \node[font=\tiny] at (3.75, -2.45) {90\%};

    % k=2
    \fill[nanosprimary!60] (5, -2) rectangle (5.5, -2.09);
    \node[font=\tiny, below] at (5.25, -3) {k=2};
    \node[font=\tiny] at (5.25, -2.35) {99\%};

    % k=3
    \fill[nanosgreen!60] (6.5, -2) rectangle (7, -2.009);
    \node[font=\tiny, below] at (6.75, -3) {k=3};
    \node[font=\tiny] at (6.75, -2.35) {99.9\%};

    % Axis
    \draw[->] (3.2, -3) -- (3.2, -1.8);
    \node[font=\tiny, rotate=90] at (2.9, -2.4) {P(pérdida)};
\end{tikzpicture}
\caption{Supervivencia de evidencia: con 3 receptores, la probabilidad de pérdida es solo 0.1\%}
\label{fig:evidence-survival}
\end{figure}

\begin{infobox}[Supervivencia de Evidencia]
Con 3 receptores de confianza y probabilidad de compromiso 10\% por nodo,
la evidencia sobrevive con probabilidad $1 - 0.1^3 = 99.9\%$.
``Los muertos hablan a través de los vivos.''
\end{infobox}

%-------------------------------------------------------------------------------
\chapter{Sistema Inmune Artificial (AIS) (v0.6)}
%-------------------------------------------------------------------------------

El sistema inmune biológico no necesita conocer los patógenos de antemano ---
simplemente reconoce lo que \textbf{no es propio} y lo elimina. NanOS v0.6
implementa este concepto con el algoritmo de \textbf{Selección Negativa}.

\begin{infobox}[Filosofía del AIS]
``El sistema inmune del swarm no necesita saber qué aspecto tienen los ataques ---
solo necesita saber qué aspecto tiene `saludable'.''
\end{infobox}

\section{Conceptos Biológicos}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    concept/.style={draw, rounded corners, minimum width=3.5cm,
                    minimum height=2cm, text centered, font=\small},
    scale=0.9
]
    % Biological concepts
    \node[concept, fill=nanossecondary!20] (bio1) at (0,0) {
        \begin{tabular}{c}
            \textbf{Timo}\\
            \small Genera células T\\
            \small Elimina auto-reactivas
        \end{tabular}
    };

    \node[concept, fill=nanosaccent!20] (bio2) at (4.5,0) {
        \begin{tabular}{c}
            \textbf{Selección Negativa}\\
            \small Solo sobreviven\\
            \small las ``no-self''
        \end{tabular}
    };

    \node[concept, fill=nanosgreen!20] (bio3) at (9,0) {
        \begin{tabular}{c}
            \textbf{Células de Memoria}\\
            \small Detectores exitosos\\
            \small se preservan
        \end{tabular}
    };

    % NanOS equivalents
    \node[concept, fill=nanosprimary!20] (nano1) at (0,-3) {
        \begin{tabular}{c}
            \textbf{Thymus Phase}\\
            \small 5 segundos boot\\
            \small Genera detectores
        \end{tabular}
    };

    \node[concept, fill=nanosprimary!20] (nano2) at (4.5,-3) {
        \begin{tabular}{c}
            \textbf{Maduración}\\
            \small Elimina detectores\\
            \small que matchean ``self''
        \end{tabular}
    };

    \node[concept, fill=nanosprimary!20] (nano3) at (9,-3) {
        \begin{tabular}{c}
            \textbf{Promoción}\\
            \small Detectores exitosos\\
            \small → memoria (x2 peso)
        \end{tabular}
    };

    % Arrows
    \draw[->, thick, gray] (bio1) -- (nano1);
    \draw[->, thick, gray] (bio2) -- (nano2);
    \draw[->, thick, gray] (bio3) -- (nano3);

    % Labels
    \node[font=\tiny\bfseries, above] at (4.5, 1.2) {Sistema Inmune Biológico};
    \node[font=\tiny\bfseries, below] at (4.5, -4.2) {NanOS AIS};

\end{tikzpicture}
\caption{Mapeo de conceptos inmunológicos a la implementación NanOS}
\label{fig:ais-concepts}
\end{figure}

\section{Estructura del Detector}

Un detector es un ``anticuerpo digital'' que reconoce patrones anómalos:

\begin{lstlisting}[caption={Estructura del detector AIS}]
#define AIS_DETECTOR_COUNT      16      /* Detectores activos */
#define AIS_DETECTOR_SIZE       8       /* Bytes por patron */
#define AIS_AFFINITY_THRESHOLD  6       /* Bits contiguos para match */

struct ais_detector {
    uint8_t  pattern[8];        /* Patron del detector */
    uint8_t  mask[8];           /* Que bits comparar */
    uint8_t  state;             /* EMPTY, IMMATURE, MATURE, MEMORY */
    uint8_t  detect_type;       /* Tipo de deteccion si conocido */
    uint16_t matches;           /* Veces que matcheo no-self */
    uint16_t false_positives;   /* Matcheo self (malo) */
    uint32_t created_tick;      /* Cuando se creo */
    uint32_t last_match_tick;   /* Ultimo match exitoso */
};

/* Estados del detector */
#define AIS_DETECTOR_EMPTY      0x00    /* Slot disponible */
#define AIS_DETECTOR_IMMATURE   0x01    /* En thymus, aprendiendo */
#define AIS_DETECTOR_MATURE     0x02    /* Activo, detecta no-self */
#define AIS_DETECTOR_MEMORY     0x03    /* Promovido a memoria */
#define AIS_DETECTOR_ANERGIC    0x04    /* Deshabilitado (matcheo self) */
\end{lstlisting}

\section{Algoritmo de Selección Negativa}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    step/.style={draw, rounded corners, minimum width=2.8cm,
                 minimum height=1.4cm, text centered, font=\scriptsize},
    decision/.style={draw, diamond, aspect=2, minimum width=2cm,
                     minimum height=1cm, text centered, font=\scriptsize},
    arrow/.style={->, thick},
    scale=0.85
]
    % Generation
    \node[step, fill=nanossecondary!20] (gen) at (0,0) {
        \begin{tabular}{c}
            \textbf{1. Generar}\\
            Patrón aleatorio
        \end{tabular}
    };

    % Thymus check
    \node[decision, fill=nanosaccent!20] (thymus) at (4,0) {
        \begin{tabular}{c}
            ¿Matchea\\
            ``self''?
        \end{tabular}
    };

    % Cull
    \node[step, fill=nanosgray!30] (cull) at (4,2.5) {
        \begin{tabular}{c}
            \textbf{ELIMINAR}\\
            Auto-reactivo
        \end{tabular}
    };

    % Mature
    \node[step, fill=nanosgreen!20] (mature) at (8,0) {
        \begin{tabular}{c}
            \textbf{2. Madurar}\\
            MADURO
        \end{tabular}
    };

    % Detection
    \node[decision, fill=nanosprimary!20] (detect) at (12,0) {
        \begin{tabular}{c}
            ¿Matchea\\
            tráfico?
        \end{tabular}
    };

    % Normal
    \node[step, fill=nanosgray!20] (normal) at (12,-2.5) {
        \begin{tabular}{c}
            \textbf{Normal}\\
            Sin anomalía
        \end{tabular}
    };

    % Anomaly
    \node[step, fill=nanosaccent!40] (anomaly) at (16,0) {
        \begin{tabular}{c}
            \textbf{3. ANOMALÍA}\\
            Detectada
        \end{tabular}
    };

    % Response actions
    \node[step, fill=nanosgreen!30] (stigmergia) at (14,2.5) {
        \begin{tabular}{c}
            Emit\\
            DANGER
        \end{tabular}
    };

    \node[step, fill=nanosprimary!30] (blackbox) at (17,2.5) {
        \begin{tabular}{c}
            Record\\
            Event
        \end{tabular}
    };

    % Arrows
    \draw[arrow] (gen) -- (thymus);
    \draw[arrow] (thymus) -- node[right, font=\tiny] {SÍ} (cull);
    \draw[arrow] (thymus) -- node[above, font=\tiny] {NO} (mature);
    \draw[arrow] (mature) -- (detect);
    \draw[arrow] (detect) -- node[right, font=\tiny] {NO} (normal);
    \draw[arrow] (detect) -- node[above, font=\tiny] {SÍ} (anomaly);
    \draw[arrow] (anomaly) -- (stigmergia);
    \draw[arrow] (anomaly) -- (blackbox);
    \draw[arrow, dashed] (cull) -| (gen);

\end{tikzpicture}
\caption{Flujo del algoritmo de Selección Negativa}
\label{fig:ais-flow}
\end{figure}

\section{Extracción de Antígenos}

Cada paquete se convierte en un ``antígeno'' de 8 bytes para comparación:

\begin{lstlisting}[caption={Extracción de características del paquete}]
struct ais_antigen {
    uint8_t features[8];        /* Vector de caracteristicas */
    uint16_t source_node;       /* Nodo origen */
    uint8_t pheromone_type;     /* Tipo de paquete */
    uint8_t context_flags;      /* Contexto de seguridad */
};

/* Caracteristicas extraidas del paquete */
void ais_extract_antigen(struct nanos_pheromone* pkt,
                         struct ais_antigen* antigen,
                         uint8_t ctx_flags) {
    antigen->features[0] = pkt->type;           /* Tipo */
    antigen->features[1] = pkt->ttl;            /* TTL */
    antigen->features[2] = pkt->hop_count;      /* Saltos */
    antigen->features[3] = (uint8_t)pkt->node_id;  /* ID origen */
    antigen->features[4] = pkt->distance;       /* Distancia */
    antigen->features[5] = ctx_flags;           /* Contexto */
    antigen->features[6] = (uint8_t)pkt->seq;   /* Secuencia */
    antigen->features[7] = pkt->flags;          /* Flags */
}
\end{lstlisting}

\section{Tipos de Detección}

\begin{table}[H]
\centering
\begin{tabular}{clp{7cm}}
\toprule
\textbf{Código} & \textbf{Tipo} & \textbf{Descripción} \\
\midrule
0x01 & FLOOD & Patrón de DoS/flooding \\
0x02 & PROBE & Reconocimiento/escaneo de red \\
0x03 & REPLAY & Patrón de ataque de replay \\
0x04 & INJECTION & Inyección de paquetes maliciosos \\
0x05 & BEHAVIORAL & Comportamiento anómalo de nodo \\
0x06 & SYBIL & Múltiples identidades desde una fuente \\
0xFF & UNKNOWN & \textbf{Anomalía desconocida (0-day!)} \\
\bottomrule
\end{tabular}
\caption{Tipos de detección del AIS}
\label{tab:ais-detect-types}
\end{table}

\section{Perfil ``Self'' (Qué es Normal)}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8]
    % Radar chart for self profile
    \def\radius{3}

    % Axes
    \foreach \i/\label in {0/PKT\_RATE, 1/AVG\_SIZE, 2/ENTROPY, 3/SRC\_DIV,
                           4/HMAC\_FAIL, 5/REPLAY, 6/CHURN, 7/STABILITY} {
        \draw[gray!50] (0,0) -- ({45*\i}:\radius);
        \node[font=\tiny, rotate={45*\i-90}] at ({45*\i}:\radius+0.7) {\label};
    }

    % Circles
    \foreach \r in {1,2,3} {
        \draw[gray!30] (0,0) circle (\r);
    }

    % Self profile (example values)
    \draw[fill=nanosgreen!30, draw=nanosgreen, thick]
        ({45*0}:1.5) -- ({45*1}:2) -- ({45*2}:1.8) -- ({45*3}:2.5)
        -- ({45*4}:0.5) -- ({45*5}:0.3) -- ({45*6}:1.2) -- ({45*7}:2.2) -- cycle;

    % Anomaly example
    \draw[fill=nanosaccent!30, draw=nanosaccent, thick, dashed]
        ({45*0}:2.8) -- ({45*1}:1) -- ({45*2}:0.5) -- ({45*3}:0.8)
        -- ({45*4}:2.5) -- ({45*5}:2.2) -- ({45*6}:2.8) -- ({45*7}:0.5) -- cycle;

    % Legend
    \node[font=\small] at (5, 2) {
        \begin{tabular}{ll}
            \tikz\fill[nanosgreen!30] (0,0) rectangle (0.3,0.3); & Self (normal)\\
            \tikz\fill[nanosaccent!30] (0,0) rectangle (0.3,0.3); & Anomalía
        \end{tabular}
    };

    \node[font=\tiny, below] at (0, -4) {
        8 dimensiones de características monitoreadas
    };

\end{tikzpicture}
\caption{Perfil ``Self'' vs anomalía en el espacio de características}
\label{fig:ais-self-profile}
\end{figure}

\begin{lstlisting}[caption={Características monitoreadas para el perfil ``self''}]
/* Dimensiones del perfil self (normalizadas 0-255) */
#define AIS_FEATURE_PKT_RATE        0   /* Paquetes por segundo */
#define AIS_FEATURE_AVG_SIZE        1   /* Tamanio promedio */
#define AIS_FEATURE_TYPE_ENTROPY    2   /* Entropia de tipos */
#define AIS_FEATURE_SRC_DIVERSITY   3   /* Diversidad de fuentes */
#define AIS_FEATURE_HMAC_FAIL_RATE  4   /* Tasa de fallos HMAC */
#define AIS_FEATURE_REPLAY_RATE     5   /* Tasa de replays */
#define AIS_FEATURE_NEIGHBOR_CHURN  6   /* Cambios de vecinos */
#define AIS_FEATURE_ROUTE_STABILITY 7   /* Estabilidad de rutas */
\end{lstlisting}

\section{Integración con Otros Sistemas}

Cuando el AIS detecta una anomalía, activa una respuesta coordinada:

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    system/.style={draw, rounded corners, minimum width=2.5cm,
                   minimum height=1.5cm, text centered, font=\small},
    scale=0.85
]
    % AIS detection
    \node[system, fill=nanosaccent!30] (ais) at (0,0) {
        \begin{tabular}{c}
            \textbf{AIS}\\
            Detecta anomalía
        \end{tabular}
    };

    % Integrated systems
    \node[system, fill=nanosgreen!30] (stigmergia) at (4,1.5) {
        \begin{tabular}{c}
            \textbf{Stigmergia}\\
            Emit DANGER
        \end{tabular}
    };

    \node[system, fill=nanosprimary!30] (blackbox) at (4,0) {
        \begin{tabular}{c}
            \textbf{Black Box}\\
            Record Event
        \end{tabular}
    };

    \node[system, fill=nanossecondary!30] (hebbian) at (4,-1.5) {
        \begin{tabular}{c}
            \textbf{Hebbian}\\
            Penalizar nodo
        \end{tabular}
    };

    \node[system, fill=nanosgray!30] (alarm) at (8,0) {
        \begin{tabular}{c}
            \textbf{Broadcast}\\
            ALARM al swarm
        \end{tabular}
    };

    % Arrows
    \draw[->, thick] (ais) -- (stigmergia);
    \draw[->, thick] (ais) -- (blackbox);
    \draw[->, thick] (ais) -- (hebbian);
    \draw[->, thick] (stigmergia) -| (alarm);
    \draw[->, thick] (blackbox) -- (alarm);
    \draw[->, thick] (hebbian) -| (alarm);

\end{tikzpicture}
\caption{Respuesta coordinada del AIS con otros sistemas NanOS}
\label{fig:ais-integration}
\end{figure}

\section{API del Sistema Inmune}

\begin{lstlisting}[caption={Funciones principales del AIS}]
/* Inicializar AIS - inicia thymus phase */
void ais_init(void);

/* Llamar periodicamente desde main loop */
void ais_tick(void);

/* Procesar paquete a traves del sistema inmune */
uint8_t ais_process_packet(struct nanos_pheromone* pkt, uint8_t ctx_flags);

/* Verificar si maduracion completa */
bool ais_is_mature(void);

/* Obtener estadisticas */
uint8_t ais_get_active_detector_count(void);
uint32_t ais_get_detection_count(void);

/* Debug */
void ais_print_status(void);
\end{lstlisting}

\section{Eventos AIS para Black Box}

\begin{lstlisting}[caption={Eventos del AIS registrados en Black Box}]
#define EVENT_AIS_DETECTOR_MATCH    0x10    /* Detector matcheo no-self */
#define EVENT_AIS_THYMUS_COMPLETE   0x11    /* Maduracion completa */
#define EVENT_AIS_MEMORY_PROMOTE    0x12    /* Detector promovido */
#define EVENT_AIS_ANOMALY_ALERT     0x13    /* Umbral de anomalia */
#define EVENT_AIS_SELF_UPDATE       0x14    /* Perfil self actualizado */
\end{lstlisting}

\begin{infobox}[Detección de 0-Days]
El AIS no necesita firmas de ataques conocidos. Cualquier patrón que no coincida
con el perfil ``self'' aprendido durante la fase thymus es considerado sospechoso.
Esto permite detectar ataques completamente nuevos (0-days) que nunca se han visto antes.
\end{infobox}

%-------------------------------------------------------------------------------
\chapter{Polimorfismo de Código: ``El Camaleón'' (v0.6)}
\label{chap:polymorph}
%-------------------------------------------------------------------------------

El módulo de \textbf{Polimorfismo de Código} (``El Camaleón'') proporciona diversidad
a nivel binario, asegurando que cada nodo del swarm tenga una huella digital única.
Esto hace imposible reutilizar exploits entre nodos.

\section{Motivación}

En ataques tradicionales, una vez que un atacante desarrolla un exploit para una
vulnerabilidad, puede reutilizarlo contra cualquier sistema que ejecute el mismo binario.
El polimorfismo rompe este paradigma:

\begin{center}
\begin{tikzpicture}[node distance=2.5cm]
    % Nodes
    \node[block, fill=nanosaccent!30] (attacker) {Atacante};
    \node[block, fill=nanossecondary!30, right=of attacker] (node1) {Nodo A\\Firma 0x7A3F};
    \node[block, fill=nanossecondary!30, right=of node1] (node2) {Nodo B\\Firma 0xB2E1};
    \node[block, fill=nanossecondary!30, right=of node2] (node3) {Nodo C\\Firma 0x5D9C};

    % Exploit arrows
    \draw[->, thick, red] (attacker) -- (node1) node[midway, above] {Exploit A};
    \draw[->, thick, red, dashed] (attacker.north) to[bend left=30] node[above] {?} (node2.north);
    \draw[->, thick, red, dashed] (attacker.north) to[bend left=40] node[above] {?} (node3.north);

    % Labels
    \node[below=0.5cm of node1, text width=3cm, align=center] {\footnotesize Stack: +0x340\\Canary: 0xDEAD};
    \node[below=0.5cm of node2, text width=3cm, align=center] {\footnotesize Stack: +0x7A0\\Canary: 0xBEEF};
    \node[below=0.5cm of node3, text width=3cm, align=center] {\footnotesize Stack: +0x120\\Canary: 0xCAFE};
\end{tikzpicture}
\end{center}

\begin{infobox}[Principio Fundamental]
``Si un atacante compromete un nodo, ha ganado una batalla.
Para comprometer el swarm, tendría que ganar miles de batallas diferentes.''
\end{infobox}

\section{Componentes del Polimorfismo}

\subsection{ASLR (Address Space Layout Randomization)}

Randomización del layout de memoria al boot:

\begin{lstlisting}[caption={Configuración de ASLR}]
/* Bits de entropia (limitados por constraints de MCU) */
#define POLY_ASLR_STACK_BITS    8   /* 256 bases posibles para stack */
#define POLY_ASLR_HEAP_BITS     6   /* 64 bases posibles para heap */
#define POLY_ASLR_ALIGNMENT     16  /* Alineacion de 16 bytes (ARM) */

#define POLY_STACK_OFFSET_MAX   4096    /* Max randomizacion stack */
#define POLY_HEAP_OFFSET_MAX    1024    /* Max randomizacion heap */

struct poly_memory_layout {
    uint32_t stack_base;        /* Base randomizada del stack */
    uint32_t stack_offset;      /* Offset desde base original */
    uint32_t heap_base;         /* Base randomizada del heap */
    uint32_t heap_offset;       /* Offset desde base original */
    uint32_t data_offset;       /* Offset de datos estaticos */
    uint32_t entropy_seed;      /* Semilla usada */
};
\end{lstlisting}

\subsection{Stack Canaries}

Valores aleatorios para detectar buffer overflows:

\begin{lstlisting}[caption={Protección con Stack Canary}]
struct poly_canary_state {
    uint32_t value;         /* Valor actual del canary */
    uint32_t backup;        /* Backup para verificacion */
    uint32_t violations;    /* Contador de violaciones */
    uint32_t last_check;    /* Ultimo tick de verificacion */
    uint32_t last_refresh;  /* Ultimo tick de refresh */
};

/* Macros de instrumentacion */
#define POLY_CANARY_PROLOGUE() \
    uint32_t __canary = poly_canary_get()
#define POLY_CANARY_EPILOGUE() \
    if (__canary != poly_canary_get()) poly_canary_violated()

/* Ejemplo de uso */
POLY_PROTECTED_FUNC void critical_operation(void) {
    POLY_CANARY_PROLOGUE();
    /* ... codigo critico ... */
    POLY_CANARY_EPILOGUE();
}
\end{lstlisting}

\subsection{Firma Binaria Única}

Cada nodo genera una firma de 128 bits que lo identifica:

\begin{lstlisting}[caption={Estructura de Firma Binaria}]
#define POLY_SIGNATURE_SIZE     16  /* 128 bits */

struct poly_signature {
    uint8_t  bytes[POLY_SIGNATURE_SIZE];  /* Fingerprint unico */
    uint32_t created_tick;                 /* Cuando fue generado */
    uint32_t node_id;                      /* ID del nodo asociado */
    uint8_t  version;                      /* Version de firma */
};

/* La firma se deriva de:
 * - Node ID
 * - Hardware RNG seed
 * - Boot timestamp
 * - Memory layout entropy
 */
\end{lstlisting}

\subsection{Timing Jitter}

Delays aleatorios para resistir ataques de timing side-channel:

\begin{lstlisting}[caption={Timing Jitter para Side-Channel Resistance}]
#define POLY_JITTER_MIN_US      10      /* Min jitter */
#define POLY_JITTER_MAX_US      100     /* Max jitter */

#define POLY_TIMING_SAFE(code) do { \
    poly_apply_jitter(); \
    code; \
    poly_apply_jitter(); \
} while(0)

/* Uso: proteger comparaciones criptograficas */
POLY_TIMING_SAFE(
    result = crypto_verify(expected, received);
);
\end{lstlisting}

\section{Flujo de Inicialización}

\begin{center}
\begin{tikzpicture}[node distance=1.8cm, auto]
    % States
    \node[block, fill=nanosgray!30] (uninit) {UNINITIALIZED};
    \node[block, fill=nanosaccent!30, below=of uninit] (init) {INITIALIZING};
    \node[block, fill=nanosgreen!30, below=of init] (active) {ACTIVE};
    \node[block, fill=red!40, right=3cm of active] (compromised) {COMPROMISED};

    % Transitions
    \draw[->, thick] (uninit) -- (init) node[midway, right] {\texttt{poly\_init()}};
    \draw[->, thick] (init) -- (active) node[midway, right, text width=4cm] {
        \footnotesize
        1. Apply ASLR\\
        2. Init canary\\
        3. Generate signature
    };
    \draw[->, thick, red] (active) -- (compromised) node[midway, above] {Canary violation};

    % Compromised actions
    \node[right=0.5cm of compromised, text width=4cm, align=left] {
        \footnotesize
        \textbullet\ Black Box event\\
        \textbullet\ ALARM broadcast\\
        \textbullet\ Apoptosis
    };
\end{tikzpicture}
\end{center}

\section{API Principal}

\begin{lstlisting}[caption={API del módulo Polimorfismo}]
/* Inicializacion */
int poly_init(void);

/* ASLR */
struct poly_memory_layout* poly_apply_aslr(uint32_t entropy);
struct poly_memory_layout* poly_get_layout(void);

/* Firma binaria */
void poly_generate_signature(void);
struct poly_signature* poly_get_signature(void);
bool poly_verify_signature(struct poly_signature* sig);

/* Stack canary */
void poly_canary_init(void);
uint32_t poly_canary_get(void);
bool poly_canary_check(void);
void poly_canary_refresh(void);
void poly_canary_violated(void);  /* Trigger security response */

/* Timing jitter */
void poly_apply_jitter(void);
uint16_t poly_get_jitter(void);
void poly_randomize_jitter(void);

/* Mantenimiento */
void poly_tick(void);  /* Llamar desde main loop */
bool poly_is_active(void);

/* Debug */
uint8_t poly_diversity_score(void);  /* 0-255, mayor = mas diverso */
void poly_print_status(void);
\end{lstlisting}

\section{Respuesta a Violación de Canary}

Cuando se detecta corrupción del stack canary:

\begin{enumerate}
    \item \textbf{Estado} $\rightarrow$ \texttt{COMPROMISED}
    \item \textbf{Black Box}: Registra \texttt{EVENT\_CORRUPTION}
    \item \textbf{Broadcast}: Emite \texttt{PHEROMONE\_ALARM} (0xCADEAD00)
    \item \textbf{Apoptosis}: El nodo se auto-destruye para proteger al swarm
\end{enumerate}

\begin{lstlisting}[caption={Manejo de violación de canary}]
void poly_canary_violated(void) {
    /* Cambiar estado */
    poly_state.state = POLY_STATE_COMPROMISED;
    poly_state.canary.violations++;

    /* Registrar en Black Box */
    blackbox_record_event(EVENT_CORRUPTION, 0,
        poly_state.canary.value, poly_state.canary.backup);

    /* Alertar al swarm */
    uint32_t alarm = 0xCADEAD00;
    nert_send_critical(0x0000, PHEROMONE_ALARM, &alarm, 4);

    /* Apoptosis */
    hal_trigger_apoptosis();
}
\end{lstlisting}

\section{Diversity Score}

El \texttt{diversity\_score} cuantifica qué tan único es un nodo:

\begin{lstlisting}[caption={Cálculo del Diversity Score}]
uint8_t poly_diversity_score(void) {
    uint8_t score = 0;

    /* ASLR contribuye bits de entropia */
    score += __builtin_popcount(layout.stack_offset & 0xFF) * 8;
    score += __builtin_popcount(layout.heap_offset & 0x3F) * 8;

    /* Canary contribuye bits unicos */
    score += __builtin_popcount(canary.value) * 4;

    /* Signature contribuye entropia */
    for (int i = 0; i < 16; i++) {
        score += __builtin_popcount(signature.bytes[i]);
    }

    return score;  /* 0-255, promedio esperado ~128 */
}
\end{lstlisting}

\begin{infobox}[Seguridad del Swarm]
Con polimorfismo activo, un atacante necesitaría desarrollar un exploit diferente
para cada nodo del swarm. Para 1000 nodos con 16,384 combinaciones de ASLR cada uno,
la complejidad del ataque crece exponencialmente.
\end{infobox}

%-------------------------------------------------------------------------------
\chapter{Validación de Hardware: ``El Centinela del Silicio'' (v0.6)}
\label{chap:hwval}
%-------------------------------------------------------------------------------

El módulo de \textbf{Validación de Hardware} (``El Centinela del Silicio'') proporciona
monitoreo continuo de la integridad del hardware para detectar manipulación física,
sensores comprometidos y ataques de fault injection.

\section{Motivación}

El software puede ser engañado, pero el hardware torturado revela la verdad:

\begin{itemize}
    \item \textbf{Glitching de reloj}: Manipulación de frecuencia para saltar instrucciones
    \item \textbf{Fault injection}: Picos de voltaje para corromper datos
    \item \textbf{Ataques térmicos}: Freeze/heat para afectar la memoria
    \item \textbf{Sensores falsificados}: Lecturas manipuladas de temperatura/voltaje
    \item \textbf{Firmware alterado}: Modificación no autorizada del código
\end{itemize}

\begin{center}
\begin{tikzpicture}[node distance=2cm]
    % Layers
    \node[block, fill=nanosaccent!30, minimum width=6cm] (hw) {Hardware Físico};
    \node[block, fill=nanossecondary!30, minimum width=6cm, above=0.5cm of hw] (sensors) {Sensores (Temp, Voltaje, Clock)};
    \node[block, fill=nanosgreen!30, minimum width=6cm, above=0.5cm of sensors] (hwval) {Hardware Validation};
    \node[block, fill=nanosprimary!30, minimum width=6cm, above=0.5cm of hwval] (sw) {Software NanOS};

    % Attack arrows
    \draw[->, thick, red] (-4,0) -- (hw.west) node[midway, above, sloped] {\tiny Fault Injection};
    \draw[->, thick, red] (-4,1) -- (sensors.west) node[midway, above, sloped] {\tiny Sensor Tampering};
    \draw[->, thick, red] (-4,2) -- (hwval.west) node[midway, above, sloped] {\tiny Clock Glitch};

    % Detection
    \node[right=2cm of hwval, text width=3cm, align=left] {\footnotesize Detecta anomalías\\antes de que\\afecten el software};
\end{tikzpicture}
\end{center}

\section{Fases del Sistema}

\begin{enumerate}
    \item \textbf{CALIBRATING} (5s): Aprende baseline de sensores
    \item \textbf{ACTIVE}: Monitoreo continuo normal
    \item \textbf{SUSPICIOUS}: Anomalías detectadas, alerta elevada
    \item \textbf{COMPROMISED}: Integridad fallida, apoptosis
\end{enumerate}

\section{Validación de Sensores}

\begin{lstlisting}[caption={Límites físicos de sensores}]
/* Temperatura operacional */
#define HWVAL_TEMP_MIN_C        (-40)   /* -40C minimo */
#define HWVAL_TEMP_MAX_C        85      /* 85C maximo */
#define HWVAL_TEMP_DELTA_MAX    10      /* Max cambio/segundo */

/* Voltaje de operacion */
#define HWVAL_VOLTAGE_MIN_MV    2700    /* 2.7V minimo */
#define HWVAL_VOLTAGE_MAX_MV    3600    /* 3.6V maximo */
#define HWVAL_VOLTAGE_DELTA_MAX 100     /* Max cambio/tick (mV) */

/* Tolerancia de reloj */
#define HWVAL_CLOCK_TOLERANCE_PCT   5   /* 5% drift permitido */
#define HWVAL_CLOCK_GLITCH_THRESH   3   /* Glitches antes de alarma */
\end{lstlisting}

\section{Canaries de Memoria}

\begin{lstlisting}[caption={Protección con Memory Canaries}]
#define HWVAL_MEM_CANARY_COUNT  4
#define HWVAL_MEM_CANARY_MAGIC  0xC0DEBABE

struct hwval_mem_canary {
    uint32_t *address;      /* Ubicacion del canary */
    uint32_t expected;      /* Valor esperado */
    uint8_t  region;        /* RAM/FLASH/etc */
    uint8_t  violated;      /* Corrupcion detectada? */
};

/* Registrar ubicacion critica */
int idx = hwval_register_canary(&critical_var, HWVAL_REGION_RAM);

/* Verificacion periodica */
if (hwval_check_canaries() > 0) {
    /* Memoria corrompida! */
}
\end{lstlisting}

\section{Integridad de Flash}

\begin{lstlisting}[caption={Verificación CRC de Flash}]
struct hwval_flash_block {
    uint32_t start_addr;    /* Direccion inicio */
    uint32_t size;          /* Tamano del bloque */
    uint32_t crc;           /* CRC esperado */
};

/* Registrar bloque de codigo critico */
hwval_register_flash_block(0x08000000, 0x10000);

/* Verificar integridad */
if (!hwval_verify_flash_block(0)) {
    /* Firmware alterado! */
}
\end{lstlisting}

\section{Tipos de Violación}

\begin{table}[H]
\centering
\begin{tabular}{clcl}
\toprule
\textbf{Código} & \textbf{Tipo} & \textbf{Severidad} & \textbf{Descripción} \\
\midrule
0x01 & TEMP\_RANGE & CRITICAL & Temperatura fuera de límites \\
0x04 & VOLTAGE\_SPIKE & CRITICAL & Glitch de voltaje detectado \\
0x06 & CLOCK\_GLITCH & CRITICAL & Glitching de reloj \\
0x07 & MEM\_CANARY & FATAL & Canary de memoria corrompido \\
0x08 & FLASH\_CRC & FATAL & CRC de flash no coincide \\
0x0A & SENSOR\_STUCK & WARNING & Sensor no responde \\
\bottomrule
\end{tabular}
\caption{Tipos de violación de hardware}
\end{table}

\section{Trust Score}

Cada nodo calcula un ``Trust Score'' de hardware (0-255):

\begin{lstlisting}[caption={Cálculo del Trust Score}]
uint8_t hwval_trust_score(void) {
    if (state == HWVAL_STATE_COMPROMISED) return 0;

    uint8_t score = 255 - anomaly_score;

    /* Penalizar por violaciones recientes */
    score -= total_violations * 10;

    return score;
}
\end{lstlisting}

\section{API Principal}

\begin{lstlisting}[caption={API del módulo Hardware Validation}]
/* Inicializacion */
int hwval_init(void);

/* Tick periodico (llamar cada 100ms) */
void hwval_tick(void);

/* Forzar verificacion completa */
uint8_t hwval_check_now(void);

/* Hardware confiable? */
bool hwval_is_trusted(void);

/* Registrar canary de memoria */
int hwval_register_canary(uint32_t *address, uint8_t region);

/* Registrar bloque flash para CRC */
int hwval_register_flash_block(uint32_t start, uint32_t size);

/* Obtener trust score */
uint8_t hwval_trust_score(void);

/* Debug */
void hwval_print_status(void);
\end{lstlisting}

\begin{infobox}[Defensa en Profundidad]
Hardware Validation complementa las otras capas de seguridad:
\begin{itemize}
    \item \textbf{AIS} detecta anomalías de red
    \item \textbf{Polimorfismo} hace únicos los binarios
    \item \textbf{Hardware Validation} detecta ataques físicos
\end{itemize}
Un atacante debe superar todas las capas para comprometer un nodo.
\end{infobox}

%-------------------------------------------------------------------------------
\chapter{Sintonización Genética (v0.7)}
%-------------------------------------------------------------------------------

\section{Visión General}

El sistema de \textbf{Sintonización Genética} permite a la Queen (micrOS) optimizar
automáticamente los parámetros del protocolo NERT utilizando algoritmos genéticos.
Los Workers reciben configuraciones de genoma y reportan métricas de rendimiento
para que la Queen evalúe el fitness de cada configuración.

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    box/.style={draw, rounded corners, minimum width=3cm, minimum height=1.2cm,
                text centered, font=\small},
    scale=0.85
]
    % Queen
    \node[box, fill=nanosaccent!30] (queen) at (0,3) {Queen (micrOS)};
    \node[font=\tiny, below=0.1cm of queen] {Motor Genético};

    % Workers
    \node[box, fill=nanosprimary!20] (w1) at (-4,0) {Worker A};
    \node[box, fill=nanosprimary!20] (w2) at (0,0) {Worker B};
    \node[box, fill=nanosprimary!20] (w3) at (4,0) {Worker C};

    % Arrows down
    \draw[arrow] (queen) -- node[left, font=\tiny, sloped] {CONFIG\_UPDATE} (w1);
    \draw[arrow] (queen) -- node[right, font=\tiny] {CONFIG\_UPDATE} (w2);
    \draw[arrow] (queen) -- node[right, font=\tiny, sloped] {CONFIG\_UPDATE} (w3);

    % Arrows up
    \draw[arrow, dashed] (w1) to[bend right=20] node[left, font=\tiny] {TELEMETRY} (queen);
    \draw[arrow, dashed] (w2) -- node[right, font=\tiny] {TELEMETRY} (queen);
    \draw[arrow, dashed] (w3) to[bend left=20] node[right, font=\tiny] {TELEMETRY} (queen);

\end{tikzpicture}
\caption{Flujo de Sintonización Genética entre Queen y Workers}
\label{fig:genetic-flow}
\end{figure}

\section{Estructura del Genoma}

Cada genoma contiene 32 bytes de parámetros optimizables:

\begin{lstlisting}[caption={Estructura del genoma NERT}]
struct nert_genome {
    uint16_t genome_id;              // ID unico
    uint8_t  generation;             // Generacion
    uint8_t  version;                // Version estructura

    // Timing Genes
    uint16_t tick_interval_ms;       // [10-200]
    uint16_t retry_timeout_ms;       // [50-1000]
    uint8_t  max_retries;            // [2-15]
    uint8_t  window_size;            // [1-8]

    // Gossip Genes
    uint8_t  gossip_prob_base;       // [50-100]
    uint8_t  gossip_prob_decay;      // [10-60]
    uint8_t  jitter_min_ms;          // [5-50]
    uint8_t  jitter_max_ms;          // [50-200]

    // Security Genes
    uint8_t  rate_bucket_capacity;   // [5-50]
    uint8_t  reputation_warn;        // [50-90]
    uint8_t  reputation_ban;         // [10-40]

    uint16_t fitness_score;          // Calculado [0-10000]
    uint16_t checksum;               // CRC16
};
\end{lstlisting}

\section{Recepción de Configuración}

Cuando un Worker recibe un pheromone \texttt{CONFIG\_UPDATE} de la Queen:

\begin{enumerate}
    \item Verificar HMAC (solo Queen puede enviar configuraciones)
    \item Validar CRC16 del genoma
    \item Verificar que todos los parámetros estén en rango
    \item Aplicar configuración gradualmente (evitar cambios bruscos)
    \item Registrar evento en BlackBox
\end{enumerate}

\begin{lstlisting}[caption={Procesamiento de CONFIG\_UPDATE}]
void genetic_process_config_update(const struct nanos_pheromone *pkt) {
    struct nert_genome *genome = (struct nert_genome*)pkt->payload;

    // Verificar checksum
    if (!genetic_verify_checksum(genome)) {
        blackbox_record_event(EVENT_GENETIC_BAD_CHECKSUM, genome->genome_id);
        return;
    }

    // Aplicar configuracion
    if (genetic_apply_genome(genome) == 0) {
        g_state.current_genome_id = genome->genome_id;
        g_state.genome_generation = genome->generation;
        blackbox_record_event(EVENT_GENETIC_CONFIG_APPLIED, genome->genome_id);
    }
}
\end{lstlisting}

\section{Reporte de Telemetría}

Periódicamente (cada 60 segundos), los Workers reportan métricas a la Queen:

\begin{lstlisting}[caption={Estructura de telemetría}]
struct genetic_telemetry {
    uint16_t genome_id;              // Genoma actual
    uint16_t packets_tx;             // Paquetes enviados
    uint16_t packets_rx;             // Paquetes recibidos
    uint16_t packets_dropped;        // Paquetes perdidos
    uint16_t avg_rtt_ms;             // RTT promedio
    uint8_t  neighbors_active;       // Vecinos activos
    uint8_t  security_violations;    // Violaciones de seguridad
    uint16_t uptime_minutes;         // Tiempo activo
};
\end{lstlisting}

\section{API del Receptor Genético}

\begin{lstlisting}[caption={API del receptor genético en Worker}]
// Inicializar receptor
void genetic_receiver_init(void);

// Procesar paquete CONFIG_UPDATE
void genetic_process_config_update(const struct nanos_pheromone *pkt);

// Enviar telemetria a Queen
void genetic_send_telemetry(void);

// Obtener genoma actual
uint16_t genetic_get_current_genome_id(void);

// Tick periodico (llamar desde main loop)
void genetic_tick(void);
\end{lstlisting}

%-------------------------------------------------------------------------------
\chapter{Nodos Judas: Honeypots Activos (v0.7)}
%-------------------------------------------------------------------------------

\section{Concepto}

Los \textbf{Nodos Judas} son Workers que, al detectar una intrusión, fingen
vulnerabilidad para capturar los payloads de los atacantes antes de
autodestruirse. Este sistema transforma nodos comprometidos en trampas
que generan inteligencia de amenazas.

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node/.style={circle, draw, minimum size=1.8cm, font=\small},
    attacker/.style={circle, draw, fill=red!40, dashed, minimum size=1.5cm, font=\small},
    judas/.style={circle, draw, fill=nanosaccent!40, minimum size=1.8cm, font=\small},
    queen/.style={circle, draw, fill=nanosgreen!40, minimum size=2cm, font=\small},
    scale=0.75
]
    % Attacker
    \node[attacker] (att) at (-5,0) {Atacante};

    % Judas Node
    \node[judas] (judas) at (0,0) {Judas};

    % Queen
    \node[queen] (queen) at (6,0) {Queen};

    % Attack flow
    \draw[->, thick, red] (att) -- node[above, font=\tiny] {Ataque} (judas);

    % Engagement
    \draw[->, thick, nanosaccent] (judas) -- node[above, font=\tiny] {JUDAS\_ENGAGE} (queen);
    \draw[->, thick, dashed] (judas) to[bend right=15]
        node[below, font=\tiny] {JUDAS\_CAPTURE} (queen);
    \draw[->, thick, nanosprimary] (judas) to[bend right=30]
        node[below, font=\tiny] {JUDAS\_FORENSICS} (queen);

    % Death
    \node[font=\tiny, red] at (0,-2) {$\times$ Apoptosis};

\end{tikzpicture}
\caption{Flujo de operación de un Nodo Judas}
\label{fig:judas-flow}
\end{figure}

\section{Máquina de Estados}

\begin{lstlisting}[caption={Estados del Nodo Judas}]
typedef enum {
    JUDAS_STATE_DORMANT,        // Comportamiento normal
    JUDAS_STATE_SUSPICIOUS,     // Intrusion detectada, evaluando
    JUDAS_STATE_ENGAGING,       // Fingiendo vulnerabilidad
    JUDAS_STATE_CAPTURING,      // Grabando payload del atacante
    JUDAS_STATE_DETONATING      // Apoptosis con forensics
} judas_state_t;
\end{lstlisting}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    state/.style={draw, rounded corners, minimum width=2.5cm,
                  minimum height=1cm, text centered, font=\small},
    scale=0.75
]
    % States
    \node[state, fill=nanosgreen!20] (dormant) at (0,0) {DORMANT};
    \node[state, fill=nanossecondary!20] (suspicious) at (4,0) {SUSPICIOUS};
    \node[state, fill=nanosprimary!20] (engaging) at (8,0) {ENGAGING};
    \node[state, fill=nanosaccent!20] (capturing) at (8,-3) {CAPTURING};
    \node[state, fill=red!30] (detonating) at (4,-3) {DETONATING};

    % Transitions
    \draw[arrow] (dormant) -- node[above, font=\tiny] {bad MAC} (suspicious);
    \draw[arrow] (suspicious) -- node[above, font=\tiny] {umbral} (engaging);
    \draw[arrow] (engaging) -- node[right, font=\tiny] {payload} (capturing);
    \draw[arrow] (capturing) -- node[below, font=\tiny] {completo} (detonating);
    \draw[arrow] (suspicious) to[bend right=30] node[below, font=\tiny] {timeout} (dormant);

\end{tikzpicture}
\caption{Máquina de estados del Nodo Judas}
\label{fig:judas-states}
\end{figure}

\section{Triggers de Activación}

\begin{lstlisting}[caption={Configuración de triggers Judas}]
struct judas_trigger_config {
    uint8_t  bad_mac_threshold;      // MACs fallidos para activar [3-10]
    uint8_t  replay_threshold;       // Replays para activar [2-5]
    uint8_t  probe_threshold;        // Probes anomalos [5-15]
    uint16_t engage_timeout_ms;      // Timeout en ENGAGING [5000-30000]
    uint16_t capture_max_bytes;      // Max bytes a capturar [256-1024]
    uint8_t  auto_detonate;          // Detonar automaticamente
};
\end{lstlisting}

\section{Estructura de Captura}

\begin{lstlisting}[caption={Datos capturados por Judas}]
struct judas_capture {
    uint32_t attacker_id;           // Node ID del atacante
    uint8_t  attacker_mac[6];       // MAC del atacante
    uint32_t engage_tick;           // Cuando se engancho
    uint32_t capture_tick;          // Cuando se capturo

    // Tecnicas observadas
    uint8_t  bad_mac_count;         // MACs invalidos
    uint8_t  replay_count;          // Intentos de replay
    uint8_t  probe_count;           // Probes anomalos
    uint8_t  injection_attempts;    // Intentos de inyeccion

    // Payload capturado
    uint16_t payload_len;
    uint8_t  payload[512];          // Maximo payload del atacante

    // Hash para deduplicacion
    uint32_t payload_hash;
};
\end{lstlisting}

\section{Integración con AIS}

El sistema Judas se integra con el Sistema Inmune Artificial:

\begin{lstlisting}[caption={Integración Judas-AIS}]
// En ais_on_anomaly():
if (g_state.judas_mode_enabled) {
    if (detect_type == AIS_DETECT_INJECTION ||
        detect_type == AIS_DETECT_PROBE) {
        // Transicionar a modo Judas en lugar de rechazar
        judas_enter_suspicious(source_node, detect_type);
        return;  // No alertar al atacante
    }
}
\end{lstlisting}

\section{Transmisión de Forensics}

Antes de la apoptosis, el nodo Judas transmite toda la evidencia:

\begin{lstlisting}[caption={Transmisión de forensics antes de morir}]
void judas_detonate(void) {
    // 1. Notificar a Queen
    struct judas_capture *cap = &g_judas.capture;
    pheromone_send_judas_capture(cap);

    // 2. Transmitir BlackBox completo
    blackbox_emit_last_will();

    // 3. Transmitir forensics especifico
    pheromone_send_judas_forensics(&g_judas);

    // 4. Apoptosis
    nanos_die(DEATH_REASON_JUDAS_DETONATE);
}
\end{lstlisting}

\section{API del Sistema Judas}

\begin{lstlisting}[caption={API del sistema Judas}]
// Inicializar sistema Judas
void judas_init(void);

// Habilitar/deshabilitar modo Judas
void judas_set_enabled(bool enabled);

// Transicion a estado sospechoso
void judas_enter_suspicious(uint32_t source, uint8_t trigger_type);

// Registrar actividad del atacante
void judas_record_activity(const void *data, uint16_t len);

// Forzar detonacion
void judas_detonate(void);

// Tick periodico
void judas_tick(void);

// Estado actual
judas_state_t judas_get_state(void);
\end{lstlisting}

%-------------------------------------------------------------------------------
\chapter{Canales Encubiertos (v0.7)}
%-------------------------------------------------------------------------------

\section{Visión General}

Los \textbf{Canales Encubiertos} permiten comunicación física entre nodos
utilizando side-channels como LEDs y buzzers. Esto habilita la comunicación
en entornos air-gapped donde la red tradicional no está disponible.

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    box/.style={draw, rounded corners, minimum width=3cm, minimum height=2cm,
                text centered, font=\small},
    scale=0.8
]
    % TX Node
    \node[box, fill=nanosprimary!20] (tx) at (0,0) {
        \begin{tabular}{c}
            \textbf{Nodo TX}\\
            \small LED/Buzzer
        \end{tabular}
    };

    % RX Node
    \node[box, fill=nanosgreen!20] (rx) at (8,0) {
        \begin{tabular}{c}
            \textbf{Nodo RX}\\
            \small Sensor/Mic
        \end{tabular}
    };

    % Optical channel
    \draw[->, thick, nanosaccent, decorate, decoration={snake, amplitude=2pt}]
        (tx.east) -- node[above, font=\small] {$\sim$ Luz/Sonido $\sim$} (rx.west);

\end{tikzpicture}
\caption{Comunicación por canal encubierto}
\label{fig:covert-channel}
\end{figure}

\section{Canal Óptico (LED-to-Light Sensor)}

\subsection{Características}

\begin{itemize}
    \item \textbf{Transmisor}: LED controlado por PWM
    \item \textbf{Receptor}: Fotorresistor o fotodiodo conectado a ADC
    \item \textbf{Modulación}: On-Off Keying (OOK) o Manchester
    \item \textbf{Velocidad}: 10--100 bps
    \item \textbf{Alcance}: 1--5 metros (dependiente de luz ambiental)
\end{itemize}

\subsection{Codificación Manchester}

Manchester encoding proporciona auto-sincronización:

\begin{lstlisting}[caption={Codificación Manchester}]
// Bit 0: transicion HIGH->LOW en mitad del periodo
// Bit 1: transicion LOW->HIGH en mitad del periodo

void covert_manchester_encode_bit(uint8_t bit) {
    if (bit) {
        // Bit 1: LOW primera mitad, HIGH segunda mitad
        led_set(0);
        delay_us(BIT_PERIOD_US / 2);
        led_set(1);
        delay_us(BIT_PERIOD_US / 2);
    } else {
        // Bit 0: HIGH primera mitad, LOW segunda mitad
        led_set(1);
        delay_us(BIT_PERIOD_US / 2);
        led_set(0);
        delay_us(BIT_PERIOD_US / 2);
    }
}
\end{lstlisting}

\section{Canal Acústico (Buzzer-to-Mic)}

\subsection{Características}

\begin{itemize}
    \item \textbf{Transmisor}: Buzzer piezoeléctrico con PWM
    \item \textbf{Receptor}: Micrófono analógico o I2S
    \item \textbf{Modulación}: FSK (Frequency Shift Keying)
    \item \textbf{Frecuencias}: 1kHz/2kHz (audible) o 18kHz/20kHz (ultrasónico)
    \item \textbf{Velocidad}: 50--200 bps
\end{itemize}

\subsection{Modulación FSK}

\begin{lstlisting}[caption={Modulación FSK para canal acústico}]
#define FREQ_ZERO   1000    // Hz para bit 0
#define FREQ_ONE    2000    // Hz para bit 1
#define BIT_TIME_MS 20      // Duracion de cada bit

void covert_fsk_send_bit(uint8_t bit) {
    uint16_t freq = bit ? FREQ_ONE : FREQ_ZERO;
    buzzer_set_frequency(freq);
    buzzer_enable();
    delay_ms(BIT_TIME_MS);
    buzzer_disable();
}
\end{lstlisting}

\section{Estructura del Frame}

\begin{lstlisting}[caption={Estructura del frame covert}]
#define COVERT_SYNC_PATTERN     0xAA
#define COVERT_CHANNEL_OPTICAL  0x01
#define COVERT_CHANNEL_ACOUSTIC 0x02

struct covert_frame {
    uint8_t  sync_pattern;      // 0xAA para sincronizacion
    uint8_t  channel_type;      // OPTICAL o ACOUSTIC
    uint8_t  payload_len;       // 1-16 bytes
    uint8_t  payload[16];       // Datos
    uint8_t  crc8;              // Checksum
};
\end{lstlisting}

\section{API de Canales Encubiertos}

\begin{lstlisting}[caption={API de canales encubiertos}]
// Inicializar transmisor
void covert_tx_init(uint8_t channel);

// Enviar datos
int covert_tx_send(const void *data, uint8_t len);

// Inicializar receptor
void covert_rx_init(uint8_t channel, uint8_t gpio_sensor);

// Recibir datos (bloqueante con timeout)
int covert_rx_receive(void *buffer, uint8_t max_len, uint32_t timeout_ms);

// Calibrar receptor
void covert_rx_calibrate(void);

// Obtener estadisticas
void covert_get_stats(struct covert_stats *stats);
\end{lstlisting}

\section{Consideraciones de Seguridad}

\begin{warningbox}[Seguridad de Canales Encubiertos]
\begin{itemize}
    \item Los datos transmitidos por canal encubierto \textbf{deben} encriptarse
          con la misma clave de sesión NERT
    \item Incluir sequence number para prevenir replay attacks
    \item El payload máximo es 16 bytes por frame
    \item Los canales encubiertos son detectables; usar con discreción
\end{itemize}
\end{warningbox}

\begin{lstlisting}[caption={Encriptación de datos covert}]
int covert_send_secure(const void *data, uint8_t len) {
    uint8_t encrypted[16];

    // Encriptar con ChaCha8
    chacha8_encrypt(g_state.session_key, g_state.covert_nonce,
                    data, encrypted, len);

    // Incrementar nonce
    g_state.covert_nonce++;

    // Enviar por canal encubierto
    return covert_tx_send(encrypted, len);
}
\end{lstlisting}

%===============================================================================
% PART II: NERT Protocol
%===============================================================================
\part{Protocolo NERT}

%-------------------------------------------------------------------------------
\chapter{Visión General de NERT}
%-------------------------------------------------------------------------------

\section{Motivación}

Los protocolos tradicionales no satisfacen las necesidades de nodos desechables:

\begin{table}[H]
\centering
\begin{tabular}{lccc}
\toprule
\textbf{Característica} & \textbf{TCP} & \textbf{UDP} & \textbf{NERT} \\
\midrule
Confiabilidad & Siempre & Nunca & \textbf{Selectiva} \\
Encriptación & Opcional & No & \textbf{Obligatoria} \\
Handshake & 3-way & Ninguno & \textbf{2-way} \\
FEC & No & No & \textbf{Opcional} \\
Multi-path & No & No & \textbf{Sí} \\
RAM/conexión & $\sim$2KB & $\sim$0 & \textbf{$\sim$100B} \\
Optimizado para efímeros & No & Parcial & \textbf{Sí} \\
\bottomrule
\end{tabular}
\caption{Comparación de NERT con protocolos tradicionales}
\label{tab:nert-comparison}
\end{table}

\section{Clases de Confiabilidad}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    class/.style={draw, rounded corners, minimum width=3cm,
                  minimum height=2cm, text centered, font=\small},
    scale=0.8
]
    % Four classes
    \node[class, fill=nanosgray!20] (ff) at (0,0) {
        \begin{tabular}{c}
            \textbf{FIRE\_FORGET}\\
            \small 0x00\\
            \small No ACK\\
            \small No retry
        \end{tabular}
    };

    \node[class, fill=nanossecondary!20] (be) at (4,0) {
        \begin{tabular}{c}
            \textbf{BEST\_EFFORT}\\
            \small 0x01\\
            \small No ACK\\
            \small 2x retry
        \end{tabular}
    };

    \node[class, fill=nanosprimary!20] (rel) at (8,0) {
        \begin{tabular}{c}
            \textbf{RELIABLE}\\
            \small 0x02\\
            \small ACK required\\
            \small 5x retry
        \end{tabular}
    };

    \node[class, fill=nanosaccent!20] (crit) at (12,0) {
        \begin{tabular}{c}
            \textbf{CRITICAL}\\
            \small 0x03\\
            \small ACK + FEC\\
            \small 10x + multipath
        \end{tabular}
    };

    % Overhead arrow
    \draw[arrow, very thick, nanosgray] (-1.5,-2) -- (13.5,-2);
    \node[font=\small] at (6,-2.5) {Overhead $\rightarrow$};

    % Reliability arrow
    \draw[arrow, very thick, nanosgreen] (-1.5,-3) -- (13.5,-3);
    \node[font=\small] at (6,-3.5) {Confiabilidad $\rightarrow$};

\end{tikzpicture}
\caption{Clases de confiabilidad de NERT}
\label{fig:reliability-classes}
\end{figure}

%-------------------------------------------------------------------------------
\chapter{Formato de Paquete NERT}
%-------------------------------------------------------------------------------

\section{Header Estándar (20 bytes)}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.55]
    % Bit ruler
    \foreach \i in {0,4,...,28} {
        \node[font=\tiny] at (\i*0.5 + 0.25, 1.2) {\i};
    }
    \draw[thin] (0,1) -- (16,1);

    % Row 0
    \node[draw, fill=nanosprimary!20, minimum width=2cm, minimum height=0.8cm]
        at (1,0) {\small magic};
    \node[draw, fill=nanosprimary!20, minimum width=1cm, minimum height=0.8cm]
        at (2.5,0) {\tiny ver};
    \node[draw, fill=nanosprimary!20, minimum width=0.5cm, minimum height=0.8cm]
        at (3.25,0) {\tiny c};
    \node[draw, fill=nanosprimary!20, minimum width=0.5cm, minimum height=0.8cm]
        at (3.75,0) {\tiny r};
    \node[draw, fill=nanossecondary!20, minimum width=4cm, minimum height=0.8cm]
        at (6,0) {\small node\_id};

    % Row 1
    \node[draw, fill=nanossecondary!20, minimum width=4cm, minimum height=0.8cm]
        at (2,-1) {\small dest\_id};
    \node[draw, fill=nanossecondary!20, minimum width=4cm, minimum height=0.8cm]
        at (6,-1) {\small seq\_num};

    % Row 2
    \node[draw, fill=nanosgreen!20, minimum width=4cm, minimum height=0.8cm]
        at (2,-2) {\small ack\_num};
    \node[draw, fill=nanosgreen!20, minimum width=2cm, minimum height=0.8cm]
        at (5,-2) {\small flags};
    \node[draw, fill=nanosgreen!20, minimum width=2cm, minimum height=0.8cm]
        at (7,-2) {\small len};

    % Row 3
    \node[draw, fill=nanosgray!20, minimum width=4cm, minimum height=0.8cm]
        at (2,-3) {\small timestamp};
    \node[draw, fill=nanosgray!20, minimum width=2cm, minimum height=0.8cm]
        at (5,-3) {\small ttl};
    \node[draw, fill=nanosgray!20, minimum width=2cm, minimum height=0.8cm]
        at (7,-3) {\small hop};

    % Row 4
    \node[draw, fill=nanosaccent!20, minimum width=8cm, minimum height=0.8cm]
        at (4,-4) {\small nonce\_counter};

    % Byte labels
    \node[font=\tiny, anchor=east] at (-0.2,0) {0};
    \node[font=\tiny, anchor=east] at (-0.2,-1) {4};
    \node[font=\tiny, anchor=east] at (-0.2,-2) {8};
    \node[font=\tiny, anchor=east] at (-0.2,-3) {12};
    \node[font=\tiny, anchor=east] at (-0.2,-4) {16};

    % Legend
    \node[font=\scriptsize] at (12,0) {c = class (2 bits)};
    \node[font=\scriptsize] at (12,-0.5) {r = reserved};

\end{tikzpicture}
\caption{Header NERT estándar de 20 bytes}
\label{fig:nert-header}
\end{figure}

\section{Campo de Flags}

\begin{table}[H]
\centering
\begin{tabular}{ccl}
\toprule
\textbf{Bit} & \textbf{Nombre} & \textbf{Descripción} \\
\midrule
0 & SYN & Inicio de conexión \\
1 & ACK & Acknowledgment válido \\
2 & FIN & Fin de conexión \\
3 & RST & Reset/abort \\
4 & ENC & Payload encriptado (siempre 1) \\
5 & FEC & Incluye bloque FEC \\
6 & FRAG & Paquete fragmentado \\
7 & MPATH & Multi-path habilitado \\
\bottomrule
\end{tabular}
\caption{Definición de bits del campo flags}
\label{tab:flags}
\end{table}

\section{Estructura Completa del Paquete}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8]
    % Header
    \node[draw, fill=nanosprimary!20, minimum width=8cm, minimum height=1cm]
        (header) at (0,0) {\textbf{Header} (20 bytes)};

    % Payload
    \node[draw, fill=nanosgreen!20, minimum width=8cm, minimum height=1.5cm]
        (payload) at (0,-1.5) {
            \begin{tabular}{c}
                \textbf{Encrypted Payload}\\
                \small (1--255 bytes)
            \end{tabular}
        };

    % Auth tag
    \node[draw, fill=nanosaccent!20, minimum width=8cm, minimum height=0.8cm]
        (tag) at (0,-2.8) {\textbf{Poly1305 Tag} (8 bytes)};

    % Sizes
    \draw[decorate, decoration={brace, amplitude=5pt, mirror}]
        (4.2,0.5) -- (4.2,-3.2)
        node[midway, right=8pt, font=\small] {30--283 bytes total};

    % Encryption scope
    \draw[dashed, nanosaccent, thick] (-4.3,-0.7) rectangle (4.3,-2.3);
    \node[font=\tiny, nanosaccent, anchor=west] at (-4.2,-0.85) {ChaCha8 encrypted};

    % MAC scope
    \draw[dotted, nanosprimary, thick] (-4.5,0.5) rectangle (4.5,-2.5);
    \node[font=\tiny, nanosprimary, anchor=west] at (-4.4,0.35) {Poly1305 authenticated};

\end{tikzpicture}
\caption{Estructura completa del paquete NERT}
\label{fig:nert-packet}
\end{figure}

%-------------------------------------------------------------------------------
\chapter{Criptografía}
%-------------------------------------------------------------------------------

\section{Algoritmos Utilizados}

\begin{table}[H]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Función} & \textbf{Algoritmo} & \textbf{Parámetros} \\
\midrule
Encriptación & ChaCha8 & 256-bit key, 96-bit nonce \\
Autenticación & Poly1305 & 256-bit key, truncated to 64-bit \\
Key Derivation & ChaCha8-based PRF & Master key + epoch \\
\bottomrule
\end{tabular}
\caption{Algoritmos criptográficos de NERT}
\label{tab:crypto-algos}
\end{table}

\section{Derivación de Claves}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    block/.style={draw, rounded corners, minimum width=2.5cm,
                  minimum height=1cm, text centered, font=\small},
    scale=0.9
]
    % Inputs
    \node[block, fill=nanosprimary!30] (master) at (0,2) {Master Key};
    \node[block, fill=nanossecondary!30] (epoch) at (0,0) {Epoch (32-bit)};
    \node[block, fill=nanosgray!30] (const) at (0,-2) {``NERT''};

    % Concatenation
    \node[draw, circle, fill=nanosaccent!20, minimum size=1cm] (concat) at (4,0) {$\|$};

    % PRF
    \node[block, fill=nanosaccent!30, minimum width=3cm] (prf) at (8,0) {
        \begin{tabular}{c}
            ChaCha8\\
            (PRF mode)
        \end{tabular}
    };

    % Output
    \node[block, fill=nanosgreen!30] (session) at (12,0) {Session Key};

    % Connections
    \draw[arrow] (master) -| (concat);
    \draw[arrow] (epoch) -- (concat);
    \draw[arrow] (const) -| (concat);
    \draw[arrow] (concat) -- (prf);
    \draw[arrow] (prf) -- (session);

\end{tikzpicture}
\caption{Proceso de derivación de clave de sesión}
\label{fig:key-derivation}
\end{figure}

\section{Ventana de Gracia para Rotación de Claves}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.7]
    % Timeline
    \draw[thick, ->] (0,0) -- (16,0) node[right] {tiempo};

    % Epoch markers
    \draw[thick] (0,-0.3) -- (0,0.3);
    \draw[thick] (5,-0.3) -- (5,0.3);
    \draw[thick] (10,-0.3) -- (10,0.3);
    \draw[thick] (15,-0.3) -- (15,0.3);

    \node[below, font=\small] at (0,-0.3) {$E_{n-1}$};
    \node[below, font=\small] at (5,-0.3) {$E_n$};
    \node[below, font=\small] at (10,-0.3) {$E_{n+1}$};
    \node[below, font=\small] at (15,-0.3) {$E_{n+2}$};

    % Grace windows
    \fill[nanosprimary!30] (4.5,-1.5) rectangle (5.5,-2);
    \fill[nanosprimary!30] (9.5,-1.5) rectangle (10.5,-2);

    \node[font=\tiny] at (5,-1.75) {30s};
    \node[font=\tiny] at (10,-1.75) {30s};

    % Valid keys indicator
    \draw[thick, nanosgreen] (0,-3) -- (5,-3);
    \node[left, font=\scriptsize] at (0,-3) {$K_{n-1}$};

    \draw[thick, nanosprimary] (4.5,-3.5) -- (10.5,-3.5);
    \node[left, font=\scriptsize] at (4.5,-3.5) {$K_n$};

    \draw[thick, nanosaccent] (9.5,-4) -- (15,-4);
    \node[left, font=\scriptsize] at (9.5,-4) {$K_{n+1}$};

    % Legend
    \node[font=\small, anchor=west] at (0,-5) {Ventana de gracia: acepta claves de épocas adyacentes};

\end{tikzpicture}
\caption{Mecanismo de ventana de gracia para rotación de claves}
\label{fig:grace-window}
\end{figure}

\begin{warningbox}[Problema de Sincronización]
Sin sincronización de tiempo, nodos con relojes desincronizados podrían
rechazar paquetes válidos en el cambio de época. La ventana de gracia
de 30 segundos permite tolerancia a drift de hasta $\pm$30s entre nodos.
\end{warningbox}

\section{Construcción del Nonce}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8]
    % Nonce structure
    \node[draw, fill=nanosprimary!20, minimum width=2cm, minimum height=1cm]
        at (0,0) {\small node\_id};
    \node[draw, fill=nanosgray!20, minimum width=2cm, minimum height=1cm]
        at (2,0) {\small reserved};
    \node[draw, fill=nanossecondary!20, minimum width=4cm, minimum height=1cm]
        at (5,0) {\small nonce\_counter};
    \node[draw, fill=nanosgreen!20, minimum width=4cm, minimum height=1cm]
        at (9,0) {\small timestamp};

    % Byte markers
    \node[font=\tiny] at (0,-0.8) {0--1};
    \node[font=\tiny] at (2,-0.8) {2--3};
    \node[font=\tiny] at (5,-0.8) {4--7};
    \node[font=\tiny] at (9,-0.8) {8--11};

    % Total
    \draw[decorate, decoration={brace, amplitude=5pt}]
        (-1,0.7) -- (11,0.7) node[midway, above=8pt] {96 bits (12 bytes)};

\end{tikzpicture}
\caption{Estructura del nonce de 96 bits}
\label{fig:nonce}
\end{figure}

%-------------------------------------------------------------------------------
\chapter{Mecanismos de Confiabilidad}
%-------------------------------------------------------------------------------

\section{Máquina de Estados de Conexión}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    state/.style={draw, circle, minimum size=2cm, text centered, font=\small},
    scale=0.8,
    node distance=3cm
]
    % States
    \node[state, fill=nanosgray!30] (closed) at (0,0) {CLOSED};
    \node[state, align=center, fill=nanosprimary!30] (synsent) at (5,0) {SYN\\SENT};
    \node[state, fill=nanosgreen!30] (estab) at (10,0) {ESTAB};
    \node[state, align=center, fill=nanosaccent!30] (finsent) at (10,-4) {FIN\\SENT};
    \node[state, align=center, fill=nanossecondary!30] (timewait) at (5,-4) {TIME\\WAIT};

    % Transitions
    \draw[arrow] (closed) -- node[above, font=\tiny] {connect()} (synsent);
    \draw[arrow] (synsent) -- node[above, font=\tiny] {SYN+ACK} (estab);
    \draw[arrow] (estab) -- node[right, font=\tiny] {send FIN} (finsent);
    \draw[arrow] (finsent) -- node[below, font=\tiny] {recv ACK} (timewait);
    \draw[arrow] (timewait) -- node[below, font=\tiny] {2*RTT} (closed);

    % Timeout
    \draw[arrow, dashed, nanosaccent] (synsent) to[bend left=30]
        node[above, font=\tiny] {timeout} (closed);

\end{tikzpicture}
\caption{Máquina de estados de conexión NERT (simplificada)}
\label{fig:state-machine}
\end{figure}

\section{Two-Way Handshake}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.9]
    % Timeline
    \draw[thick] (0,0) -- (0,-5);
    \draw[thick] (8,0) -- (8,-5);

    \node[above, font=\bfseries] at (0,0) {Nodo A};
    \node[above, font=\bfseries] at (8,0) {Nodo B};

    % SYN
    \draw[arrow, thick, nanosprimary] (0.2,-1) -- (7.8,-1.8);
    \node[above, font=\small] at (4,-1.2) {SYN, seq=X, [data]};

    % SYN+ACK
    \draw[arrow, thick, nanosgreen] (7.8,-2.2) -- (0.2,-3);
    \node[above, font=\small] at (4,-2.4) {SYN+ACK, seq=Y, ack=X+1};

    % ACK
    \draw[arrow, thick, nanossecondary] (0.2,-3.5) -- (7.8,-4.3);
    \node[above, font=\small] at (4,-3.7) {ACK, seq=X+1, ack=Y+1, [data]};

    % Established markers
    \node[font=\scriptsize, nanosgreen] at (0,-4.7) {ESTABLISHED};
    \node[font=\scriptsize, nanosgreen] at (8,-4.7) {ESTABLISHED};

\end{tikzpicture}
\caption{Handshake de dos vías de NERT}
\label{fig:handshake}
\end{figure}

\section{Selective ACK (SACK)}

El SACK permite indicar eficientemente qué paquetes se han recibido:

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.7]
    % Received packets (green)
    \foreach \i in {100,101,104,106} {
        \pgfmathsetmacro{\x}{(\i-100)*1.5}
        \node[draw, minimum width=1.2cm, minimum height=0.8cm, fill=nanosgreen!30]
            at (\x, 0) {\small \i};
    }
    % Lost packets (red/accent)
    \foreach \i in {102,103,105,107,108} {
        \pgfmathsetmacro{\x}{(\i-100)*1.5}
        \node[draw, minimum width=1.2cm, minimum height=0.8cm, fill=nanosaccent!30]
            at (\x, 0) {\small \i};
    }

    % Legend
    \node[draw, fill=nanosgreen!30, minimum width=0.5cm, minimum height=0.5cm] at (0,-1.5) {};
    \node[right, font=\small] at (0.4,-1.5) {Recibido};

    \node[draw, fill=nanosaccent!30, minimum width=0.5cm, minimum height=0.5cm] at (4,-1.5) {};
    \node[right, font=\small] at (4.4,-1.5) {Perdido};

    % SACK representation
    \node[font=\small, anchor=west] at (0,-2.5) {SACK: base\_ack=101, bitmap=0b00101001};
    \node[font=\small, anchor=west] at (0,-3.2) {$\rightarrow$ Indica: 101 (base), 102$\times$, 103$\times$, 104\checkmark, 105$\times$, 106\checkmark};

\end{tikzpicture}
\caption{Ejemplo de Selective ACK}
\label{fig:sack}
\end{figure}

\section{Retransmisión con Backoff Exponencial}

\begin{figure}[H]
\centering
\begin{tikzpicture}
    \begin{axis}[
        width=12cm,
        height=6cm,
        xlabel={Intento de retransmisión},
        ylabel={RTO (ms)},
        xmin=0, xmax=6,
        ymin=0, ymax=2500,
        xtick={0,1,2,3,4,5},
        grid=major,
        legend pos=north west
    ]

    % RTO growth
    \addplot[thick, nanosprimary, mark=square*] coordinates {
        (0, 200) (1, 400) (2, 800) (3, 1600) (4, 2000) (5, 2000)
    };
    \addlegendentry{RTO actual}

    % Max RTO line
    \addplot[dashed, nanosaccent] coordinates {(0, 2000) (5, 2000)};
    \addlegendentry{RTO máximo}

    % Min RTO line
    \addplot[dotted, nanosgreen] coordinates {(0, 100) (5, 100)};
    \addlegendentry{RTO mínimo}

    \end{axis}
\end{tikzpicture}
\caption{Crecimiento del RTO con backoff exponencial}
\label{fig:rto-backoff}
\end{figure}

%-------------------------------------------------------------------------------
\chapter{Forward Error Correction}
%-------------------------------------------------------------------------------

\section{Esquema XOR Parity}

Para la clase CRITICAL, NERT utiliza FEC basado en XOR:

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8]
    % Data shards
    \node[draw, fill=nanosprimary!30, minimum width=2cm, minimum height=1cm]
        (d0) at (0,0) {Data 0};
    \node[draw, fill=nanosprimary!30, minimum width=2cm, minimum height=1cm]
        (d1) at (3,0) {Data 1};
    \node[draw, fill=nanosprimary!30, minimum width=2cm, minimum height=1cm]
        (d2) at (6,0) {Data 2};
    \node[draw, fill=nanosprimary!30, minimum width=2cm, minimum height=1cm]
        (d3) at (9,0) {Data 3};

    % XOR operations
    \node[draw, circle, fill=nanosaccent!20] (xor0) at (3,-2) {$\oplus$};
    \node[draw, circle, fill=nanosaccent!20] (xor1) at (6,-2) {$\oplus$};

    % Parity shards
    \node[draw, fill=nanosgreen!30, minimum width=2cm, minimum height=1cm]
        (p0) at (3,-4) {Parity 0};
    \node[draw, fill=nanosgreen!30, minimum width=2cm, minimum height=1cm]
        (p1) at (6,-4) {Parity 1};

    % Connections
    \draw[arrow] (d0) -- (xor0);
    \draw[arrow] (d2) -- (xor0);
    \draw[arrow] (d1) -- (xor1);
    \draw[arrow] (d3) -- (xor1);
    \draw[arrow] (xor0) -- (p0);
    \draw[arrow] (xor1) -- (p1);

    % Equations
    \node[font=\small, anchor=west] at (11,0) {$P_0 = D_0 \oplus D_2$};
    \node[font=\small, anchor=west] at (11,-1) {$P_1 = D_1 \oplus D_3$};

    % Recovery note
    \node[font=\small, anchor=west] at (0,-5.5) {Recuperación: $D_0 = P_0 \oplus D_2$, $D_2 = P_0 \oplus D_0$, etc.};

\end{tikzpicture}
\caption{Esquema FEC con paridad XOR}
\label{fig:fec}
\end{figure}

\section{Capacidad de Recuperación}

\begin{table}[H]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Pérdida} & \textbf{Recuperable?} \\
\midrule
1 data shard cualquiera & \textcolor{nanosgreen}{\checkmark} Sí \\
2 data shards (grupos diferentes) & \textcolor{nanosgreen}{\checkmark} Sí \\
2 data shards (mismo grupo) & \textcolor{nanosaccent}{$\times$} No \\
3+ data shards & \textcolor{nanosaccent}{$\times$} No \\
\bottomrule
\end{tabular}
\caption{Capacidad de recuperación del FEC}
\label{tab:fec-recovery}
\end{table}

%-------------------------------------------------------------------------------
\chapter{Multi-Path Transmission}
%-------------------------------------------------------------------------------

\section{Selección de Rutas}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node/.style={draw, circle, minimum size=1.2cm, text centered, font=\small},
    scale=0.9
]
    % Sender
    \node[node, fill=nanosprimary!40] (src) at (0,0) {SRC};

    % Intermediate nodes
    \node[node, fill=nanossecondary!30] (n1) at (3,2) {N1};
    \node[node, fill=nanossecondary!30] (n2) at (3,0) {N2};
    \node[node, fill=nanossecondary!30] (n3) at (3,-2) {N3};

    % More intermediate
    \node[node, fill=nanosgray!30] (n4) at (6,1) {N4};
    \node[node, fill=nanosgray!30] (n5) at (6,-1) {N5};

    % Destination
    \node[node, fill=nanosaccent!40] (dst) at (9,0) {DST};

    % Paths
    \draw[arrow, thick, nanosgreen] (src) -- (n1);
    \draw[arrow, thick, nanosgreen] (n1) -- (n4);
    \draw[arrow, thick, nanosgreen] (n4) -- (dst);

    \draw[arrow, thick, nanosprimary] (src) -- (n2);
    \draw[arrow, thick, nanosprimary] (n2) -- (dst);

    \draw[arrow, thick, nanosaccent, dashed] (src) -- (n3);
    \draw[arrow, thick, nanosaccent, dashed] (n3) -- (n5);
    \draw[arrow, thick, nanosaccent, dashed] (n5) -- (dst);

    % Legend
    \node[font=\small, nanosgreen] at (4.5,3) {Path 1};
    \node[font=\small, nanosprimary] at (4.5,2.5) {Path 2};
    \node[font=\small, nanosaccent] at (4.5,2) {Path 3};

\end{tikzpicture}
\caption{Transmisión multi-path con rutas diversas}
\label{fig:multipath}
\end{figure}

%-------------------------------------------------------------------------------
\chapter{Hive Bridge: Integración con micrOS}
%-------------------------------------------------------------------------------

\section{Arquitectura del Enjambre Híbrido}

El \textbf{Hive Bridge} permite la comunicación bidireccional entre nodos NanOS
(obreras) y micrOS (reina). Esta arquitectura híbrida combina:

\begin{itemize}
    \item \textbf{micrOS}: Sistema operativo distribuido completo actuando como reina
    \item \textbf{NanOS}: Nodos desechables actuando como obreras del enjambre
\end{itemize}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    queen/.style={circle, draw=nanosaccent, fill=nanosaccent!30,
                  minimum size=3cm, line width=2pt, font=\small},
    worker/.style={circle, draw=nanosprimary, fill=nanosprimary!20,
                   minimum size=1.5cm, font=\tiny},
    scale=0.8
]
    % Queen (micrOS)
    \node[queen] (queen) at (0,0) {
        \begin{tabular}{c}
            \textbf{micrOS}\\
            Queen\\
            ID: 0x0101
        \end{tabular}
    };

    % Workers (NanOS)
    \foreach \i/\angle in {1/30, 2/90, 3/150, 4/210, 5/270, 6/330} {
        \node[worker] (w\i) at (\angle:4cm) {
            NanOS\\
            0x0\i\i\i
        };
        \draw[->, thick, nanosprimary!60] (queen) -- (w\i);
        \draw[<-, thick, nanosgreen!60, dashed] (queen.{\angle}) -- (w\i);
    }

    % Legend
    \node[anchor=west, font=\small] at (5,2) {\textcolor{nanosprimary!60}{$\rightarrow$} ANNOUNCE/CMD};
    \node[anchor=west, font=\small] at (5,1.5) {\textcolor{nanosgreen!60}{$\leftarrow$} ECHO/DATA};

\end{tikzpicture}
\caption{Arquitectura Hive: micrOS como Queen coordinando nodos NanOS}
\label{fig:hive-bridge-arch}
\end{figure}

\section{Detección de la Reina}

Cuando un nodo NanOS detecta un paquete ANNOUNCE de micrOS:

\begin{lstlisting}[caption={Detección de micrOS como reina}]
void on_announce_received(uint16_t sender_id, const void *data, uint8_t len) {
    announce_data_t *announce = (announce_data_t*)data;

    // micrOS se anuncia con role = ROLE_QUEEN y distance = 0
    if (announce->role == ROLE_QUEEN && announce->distance == 0) {
        // Encontramos la reina!
        g_queen_id = sender_id;
        g_distance_to_queen = 1;  // Directo a la reina

        LOG_INFO("HIVE", "Queen detected: 0x%04x", sender_id);

        // Actualizar gradiente
        update_gradient(sender_id, 0);
    }
}
\end{lstlisting}

\section{Servicio NERT en micrOS}

micrOS implementa un servicio NERT que:

\begin{enumerate}
    \item \textbf{PHY Adapter}: Traduce entre el stack DOD de micrOS y NERT
    \item \textbf{Swarm State}: Mantiene estado de todos los nodos del enjambre
    \item \textbf{Polling}: Procesa pheromones incluso sin scheduler activo
\end{enumerate}

\begin{lstlisting}[caption={Estructura del estado del swarm en micrOS}]
typedef struct {
    swarm_node_entry_t nodes[32];  /* Nodos conocidos */
    uint32_t node_count;
    swarm_metrics_t metrics;       /* Metricas agregadas */
    uint16_t local_node_id;        /* ID de micrOS (queen) */
    uint8_t  initialized;
    uint8_t  running;
} swarm_state_t;
\end{lstlisting}

\section{Comunicación Bidireccional}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    box/.style={draw, rounded corners, minimum width=3cm,
                minimum height=1.2cm, text centered, font=\small},
    scale=0.9
]
    % micrOS side
    \node[box, fill=nanosaccent!20] (micros) at (0,0) {
        \begin{tabular}{c}
            \textbf{micrOS}\\
            nert\_service.c
        \end{tabular}
    };

    % NanOS side
    \node[box, fill=nanosprimary!20] (nanos) at (8,0) {
        \begin{tabular}{c}
            \textbf{NanOS}\\
            kernel.c
        \end{tabular}
    };

    % NERT Protocol layer
    \node[box, fill=nanosgreen!20, minimum width=5cm] (nert) at (4,0) {
        \begin{tabular}{c}
            \textbf{NERT Protocol}\\
            EtherType 0x4E4F
        \end{tabular}
    };

    % Arrows
    \draw[->, thick, nanosprimary] (micros.east) -- ++(0.5,0.5) -- ++(2.5,0)
        node[midway, above, font=\tiny] {ANNOUNCE, CMD, REKEY};
    \draw[->, thick, nanosgreen] (nanos.west) -- ++(-0.5,-0.5) -- ++(-2.5,0)
        node[midway, below, font=\tiny] {ECHO, ALARM, DATA};

\end{tikzpicture}
\caption{Flujo de comunicación entre micrOS y NanOS vía NERT}
\label{fig:hive-comm-flow}
\end{figure}

\section{Polling en micrOS}

Cuando el scheduler de micrOS no está activo, el shell debe pollear manualmente:

\begin{lstlisting}[caption={Polling de NERT en el shell de micrOS}]
// En micrOS shell.c
void shell_run(void) {
    while (g_running) {
        char c = keyboard_getchar_nonblock();
        if (c != 0) {
            shell_input_char(c);
        }

        // Critico: Poll NERT para comunicacion con swarm
        nert_service_poll();

        shell_cpu_halt();
    }
}
\end{lstlisting}

\begin{warningbox}[Importante]
Sin el polling manual, micrOS no procesará pheromones entrantes de los nodos
NanOS cuando el scheduler no esté realizando context switches.
\end{warningbox}

\section{Verificación de Conectividad}

Para verificar que NanOS detecta a micrOS como reina:

\begin{lstlisting}[caption={Salida esperada en NanOS}]
[NERT] RX pheromone: type=0x01 from=0x0101 dist=0
[HIVE] Queen detected: 0x0101
[GRADIENT] Updated: queen=0x0101 distance=1

# Status command shows:
> status
  Node ID:   0x0A01
  Role:      WORKER
  Queen:     0x0101
  Distance:  1
  Uptime:    42s
\end{lstlisting}

\section{Comandos de la Reina}

micrOS puede enviar comandos a los nodos NanOS mediante pheromones COMMAND:

\begin{table}[H]
\centering
\begin{tabular}{clp{5cm}}
\toprule
\textbf{Código} & \textbf{Comando} & \textbf{Descripción} \\
\midrule
0x01 & ROLE\_ASSIGN & Cambiar rol del nodo \\
0x02 & TASK\_EXEC & Ejecutar tarea específica \\
0x03 & CONFIG\_SET & Modificar configuración \\
0x10 & STATUS\_REQ & Solicitar status del nodo \\
0x13 & DIE & Ordenar apoptosis \\
\bottomrule
\end{tabular}
\caption{Comandos de la reina a nodos worker}
\label{tab:queen-commands}
\end{table}

%===============================================================================
% PART III: Implementation Guide
%===============================================================================
\part{Guía de Implementación}

%-------------------------------------------------------------------------------
\chapter{Compilación y Despliegue}
%-------------------------------------------------------------------------------

\section{Requisitos}

\begin{table}[H]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Componente} & \textbf{Versión Mínima} \\
\midrule
GCC (x86) & 9.0 \\
ARM GCC & arm-none-eabi-gcc 10.0 \\
QEMU & 6.0 \\
PlatformIO & 6.0 (para ESP32) \\
Make & 4.0 \\
\bottomrule
\end{tabular}
\caption{Requisitos de compilación}
\label{tab:requirements}
\end{table}

\section{Compilación x86}

\begin{lstlisting}[language=bash, caption={Compilación para QEMU x86}]
# Compilar kernel
make clean
make PLATFORM=x86

# Ejecutar en QEMU (3 nodos)
./scripts/run_swarm.sh 3
\end{lstlisting}

\section{Compilación ARM}

\begin{lstlisting}[language=bash, caption={Compilación para ARM Cortex-M3}]
# Compilar para Stellaris
make PLATFORM=arm

# Ejecutar en QEMU
qemu-system-arm -M lm3s6965evb \
    -kernel build/nanos_arm.elf \
    -nographic
\end{lstlisting}

\section{Compilación ESP32}

\begin{lstlisting}[language=bash, caption={Compilación con PlatformIO}]
cd platforms/esp32
pio run -e esp32dev

# Flash al dispositivo
pio run -t upload
\end{lstlisting}

%-------------------------------------------------------------------------------
\chapter{API de Programación}
%-------------------------------------------------------------------------------

\section{Inicialización}

\begin{lstlisting}[caption={Inicialización típica de NERT}]
#include "nert.h"
#include "nanos.h"

void handle_pheromone(uint16_t sender, uint8_t type,
                      const void *data, uint8_t len) {
    switch (type) {
        case PHEROMONE_HELLO:
            neighbor_update(sender, data);
            break;
        case PHEROMONE_QUEEN_CMD:
            execute_command(data);
            break;
        // ... otros tipos
    }
}

void kernel_main(void) {
    hal_init();
    nert_init();
    nert_set_receive_callback(handle_pheromone);

    while (1) {
        nert_process_incoming();
        nert_timer_tick();
        nert_check_key_rotation();

        // Logica de aplicacion
        process_role_logic();

        hal_cpu_idle();
    }
}
\end{lstlisting}

\section{Envío de Mensajes}

\begin{lstlisting}[caption={Ejemplos de envío con diferentes clases}]
// Telemetria frecuente (no garantizada)
struct sensor_data sensor = {.temp = 25, .humidity = 60};
nert_send_unreliable(0, PHEROMONE_SENSOR, &sensor, sizeof(sensor));

// Datos importantes (con retry)
struct kv_pair kv = {.key = "status", .value = "active"};
nert_send_best_effort(dest_id, PHEROMONE_KV_SET, &kv, sizeof(kv));

// Comando que requiere ACK
struct task_cmd task = {.action = ACTION_EXPLORE, .area = 5};
int conn = nert_send_reliable(worker_id, PHEROMONE_TASK,
                              &task, sizeof(task));

// Comando critico (FEC + multipath)
struct die_cmd die = {.target = rogue_node, .reason = SECURITY};
nert_send_critical(target_id, PHEROMONE_DIE, &die, sizeof(die));
\end{lstlisting}

%-------------------------------------------------------------------------------
\chapter{Debugging y Monitoreo}
%-------------------------------------------------------------------------------

\section{Estadísticas de NERT}

\begin{lstlisting}[caption={Acceso a estadísticas de protocolo}]
const struct nert_stats *stats = nert_get_stats();

printf("TX: %lu packets, %lu bytes\n",
       stats->tx_packets, stats->tx_bytes);
printf("RX: %lu packets, %lu duplicates\n",
       stats->rx_packets, stats->rx_duplicates);
printf("Retransmits: %lu\n", stats->tx_retransmits);
printf("Bad MAC: %lu, Replay blocked: %lu\n",
       stats->rx_bad_mac, stats->rx_replay_blocked);
printf("RTT: avg=%u, min=%u, max=%u\n",
       stats->avg_rtt, stats->min_rtt, stats->max_rtt);
\end{lstlisting}

\section{Métricas Clave}

\begin{table}[H]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Métrica} & \textbf{Valor Normal} & \textbf{Alerta Si} \\
\midrule
Duplicates/RX & $<$ 5\% & $>$ 20\% \\
Bad MAC rate & $<$ 0.1\% & $>$ 1\% \\
Retransmit rate & $<$ 10\% & $>$ 30\% \\
Avg RTT & $<$ 100ms & $>$ 500ms \\
Connection timeouts & 0 & $>$ 5/min \\
\bottomrule
\end{tabular}
\caption{Umbrales de métricas para monitoreo}
\label{tab:metrics}
\end{table}

%===============================================================================
% Appendices
%===============================================================================
\appendix

\chapter{Constantes de Configuración}

\begin{longtable}{llp{6cm}}
\toprule
\textbf{Constante} & \textbf{Valor} & \textbf{Descripción} \\
\midrule
\endhead

\multicolumn{3}{c}{\textit{Continúa en la siguiente página...}} \\
\endfoot

\bottomrule
\endlastfoot

NERT\_MAGIC & 0x4E & Byte mágico ('N') \\
NERT\_VERSION & 0x10 & Versión del protocolo \\
NERT\_KEY\_SIZE & 32 & Tamaño de clave en bytes \\
NERT\_NONCE\_SIZE & 12 & Tamaño de nonce en bytes \\
NERT\_MAC\_SIZE & 8 & Tamaño de tag MAC \\
NERT\_MAX\_CONNECTIONS & 4--8 & Conexiones simultáneas \\
NERT\_WINDOW\_SIZE & 2--4 & Tamaño de ventana TX \\
NERT\_RETRY\_TIMEOUT\_MS & 200 & Timeout inicial \\
NERT\_MAX\_RETRIES & 5 & Reintentos (RELIABLE) \\
NERT\_MAX\_RETRIES\_CRITICAL & 10 & Reintentos (CRITICAL) \\
NERT\_KEY\_ROTATION\_SEC & 3600 & Rotación de clave (1h) \\
NERT\_KEY\_GRACE\_WINDOW\_MS & 30000 & Ventana de gracia (30s) \\
BLOOM\_BITS & 256 & Bits del Bloom filter \\
BLOOM\_SLOTS & 4 & Slots rotativos \\
BLOOM\_WINDOW\_MS & 500 & Ventana por slot \\
MAX\_CELL\_LIFETIME & 3600000 & Vida máxima del nodo (ms) \\
HEAP\_CRITICAL\_PCT & 90 & Umbral crítico de heap \\
\midrule
\multicolumn{3}{l}{\textbf{Enrutamiento Hebbiano (v0.5)}} \\
\midrule
SYNAPSE\_WEIGHT\_MIN & 1 & Peso sináptico mínimo \\
SYNAPSE\_WEIGHT\_MAX & 255 & Peso sináptico máximo \\
SYNAPSE\_WEIGHT\_INITIAL & 128 & Peso inicial (neutral) \\
SYNAPSE\_WEIGHT\_THRESHOLD & 32 & Umbral para ruta saludable \\
SYNAPSE\_LTP\_INCREMENT & 15 & Recompensa por éxito (LTP) \\
SYNAPSE\_LTD\_DECREMENT & 40 & Castigo por fallo (LTD) \\
SYNAPSE\_STDP\_BONUS & 5 & Bonus por respuesta rápida \\
SYNAPSE\_STDP\_WINDOW\_MS & 100 & Ventana STDP (ms) \\
SYNAPSE\_DECAY\_INTERVAL\_MS & 5000 & Intervalo de decaimiento \\
SYNAPSE\_DECAY\_AMOUNT & 1 & Decremento por intervalo \\
\midrule
\multicolumn{3}{l}{\textbf{Stigmergia (v0.5)}} \\
\midrule
STIGMERGIA\_DANGER & 0 & Tipo: zona de peligro \\
STIGMERGIA\_QUEEN & 1 & Tipo: camino a reina \\
STIGMERGIA\_RESOURCE & 2 & Tipo: marcador de recurso \\
STIGMERGIA\_AVOID & 3 & Tipo: zona a evitar \\
STIGMERGIA\_INTENSITY\_MAX & 15 & Intensidad máxima (4 bits) \\
STIGMERGIA\_DECAY\_INTERVAL\_MS & 1000 & Decaimiento cada 1s \\
STIGMERGIA\_DECAY\_AMOUNT & 1 & Resta 1 por intervalo \\
STIGMERGIA\_PROPAGATE\_THRESHOLD & 6 & Min intensidad para propagar \\
STIGMERGIA\_PROPAGATE\_DECAY & 3 & Decremento al propagar \\
STIGMERGIA\_DANGER\_COST\_MULT & 8 & Multiplicador costo DANGER \\
STIGMERGIA\_AVOID\_COST\_MULT & 4 & Multiplicador costo AVOID \\
STIGMERGIA\_QUEEN\_COST\_BONUS & 2 & Bonus atracción QUEEN \\
STIGMERGIA\_SIZE & 16 & Grid 16x16 (escala 2:1) \\
\midrule
\multicolumn{3}{l}{\textbf{Black Box (v0.5)}} \\
\midrule
BLACKBOX\_MAX\_WILLS & 8 & Testamentos almacenados \\
DEATH\_NATURAL & 0x00 & Muerte natural (timeout) \\
DEATH\_HEAP\_EXHAUSTED & 0x01 & Sin memoria \\
DEATH\_CORRUPTION & 0x02 & Corrupción detectada \\
DEATH\_ATTACK\_DETECTED & 0x03 & Bajo ataque \\
DEATH\_QUEEN\_ORDER & 0x04 & Orden de la reina \\
DEATH\_ISOLATION & 0x05 & Sin contacto \\
EVENT\_BAD\_MAC & 0x01 & MAC inválido \\
EVENT\_REPLAY & 0x02 & Intento de replay \\
EVENT\_RATE\_LIMIT & 0x03 & Rate limit excedido \\
EVENT\_BLACKLIST & 0x04 & Nodo en blacklist \\
EVENT\_JAMMING & 0x05 & Jamming detectado \\
EVENT\_CORRUPTION & 0x06 & Corrupción memoria \\
\midrule
\multicolumn{3}{l}{\textbf{Sistema Inmune Artificial AIS (v0.6)}} \\
\midrule
AIS\_DETECTOR\_COUNT & 16 & Detectores activos \\
AIS\_DETECTOR\_SIZE & 8 & Bytes por patrón \\
AIS\_AFFINITY\_THRESHOLD & 6 & Bits contiguos para match \\
AIS\_MATURATION\_SAMPLES & 32 & Muestras para maduración \\
AIS\_THYMUS\_DURATION\_MS & 5000 & Fase thymus (5s) \\
AIS\_DETECTOR\_LIFESPAN\_MS & 300000 & Vida del detector (5min) \\
AIS\_ANOMALY\_THRESHOLD & 3 & Detectores para alarma \\
AIS\_MEMORY\_CELLS & 4 & Detectores de memoria \\
AIS\_MEMORY\_BOOST & 2 & Boost para memoria \\
AIS\_DETECT\_FLOOD & 0x01 & Detección: DoS/flooding \\
AIS\_DETECT\_PROBE & 0x02 & Detección: escaneo \\
AIS\_DETECT\_REPLAY & 0x03 & Detección: replay \\
AIS\_DETECT\_INJECTION & 0x04 & Detección: inyección \\
AIS\_DETECT\_BEHAVIORAL & 0x05 & Detección: comportamiento \\
AIS\_DETECT\_SYBIL & 0x06 & Detección: sybil \\
AIS\_DETECT\_UNKNOWN & 0xFF & Detección: 0-day \\
EVENT\_AIS\_DETECTOR\_MATCH & 0x10 & Detector matcheó \\
EVENT\_AIS\_THYMUS\_COMPLETE & 0x11 & Maduración completa \\
EVENT\_AIS\_MEMORY\_PROMOTE & 0x12 & Promovido a memoria \\
EVENT\_AIS\_ANOMALY\_ALERT & 0x13 & Alerta de anomalía \\
\midrule
\multicolumn{3}{l}{\textbf{Polimorfismo de Código ``El Camaleón'' (v0.6)}} \\
\midrule
POLY\_ASLR\_STACK\_BITS & 8 & Bits de entropía stack (256 bases) \\
POLY\_ASLR\_HEAP\_BITS & 6 & Bits de entropía heap (64 bases) \\
POLY\_ASLR\_ALIGNMENT & 16 & Alineación ARM (bytes) \\
POLY\_STACK\_OFFSET\_MAX & 4096 & Max offset stack (bytes) \\
POLY\_HEAP\_OFFSET\_MAX & 1024 & Max offset heap (bytes) \\
POLY\_CANARY\_SIZE & 4 & Tamaño del canary (32 bits) \\
POLY\_CANARY\_CHECK\_INTERVAL & 100 & Verificar cada N ticks \\
POLY\_CANARY\_REFRESH\_MS & 60000 & Refrescar cada 60s \\
POLY\_SIGNATURE\_SIZE & 16 & Firma única (128 bits) \\
POLY\_SIGNATURE\_REFRESH\_MS & 300000 & Refrescar firma cada 5min \\
POLY\_JITTER\_MIN\_US & 10 & Jitter mínimo ($\mu$s) \\
POLY\_JITTER\_MAX\_US & 100 & Jitter máximo ($\mu$s) \\
POLY\_NOP\_REGIONS & 4 & Regiones NOP randomizables \\
POLY\_NOP\_MAX\_SIZE & 8 & NOPs máximos por región \\
POLY\_STATE\_UNINITIALIZED & 0x00 & Estado: sin inicializar \\
POLY\_STATE\_INITIALIZING & 0x01 & Estado: inicializando \\
POLY\_STATE\_ACTIVE & 0x02 & Estado: activo \\
POLY\_STATE\_COMPROMISED & 0xFF & Estado: canary violado \\
\midrule
\multicolumn{3}{l}{\textbf{Validación de Hardware ``El Centinela del Silicio'' (v0.6)}} \\
\midrule
HWVAL\_TICK\_INTERVAL\_MS & 100 & Intervalo de verificación (ms) \\
HWVAL\_TEMP\_MIN\_C & -40 & Temperatura mínima (°C) \\
HWVAL\_TEMP\_MAX\_C & 85 & Temperatura máxima (°C) \\
HWVAL\_TEMP\_DELTA\_MAX & 10 & Max cambio temp/segundo \\
HWVAL\_VOLTAGE\_MIN\_MV & 2700 & Voltaje mínimo (mV) \\
HWVAL\_VOLTAGE\_MAX\_MV & 3600 & Voltaje máximo (mV) \\
HWVAL\_VOLTAGE\_DELTA\_MAX & 100 & Max cambio voltaje/tick \\
HWVAL\_CLOCK\_TOLERANCE\_PCT & 5 & Tolerancia drift (\%) \\
HWVAL\_CLOCK\_GLITCH\_THRESH & 3 & Glitches antes de alarma \\
HWVAL\_MEM\_CANARY\_COUNT & 4 & Canaries de memoria \\
HWVAL\_MEM\_CANARY\_MAGIC & 0xC0DEBABE & Valor mágico canary \\
HWVAL\_FLASH\_CRC\_BLOCKS & 8 & Bloques flash verificados \\
HWVAL\_ANOMALY\_THRESHOLD & 3 & Anomalías para crítico \\
HWVAL\_STATE\_CALIBRATING & 0x01 & Estado: calibrando \\
HWVAL\_STATE\_ACTIVE & 0x02 & Estado: activo \\
HWVAL\_STATE\_SUSPICIOUS & 0x03 & Estado: sospechoso \\
HWVAL\_STATE\_COMPROMISED & 0xFF & Estado: comprometido \\
EVENT\_HWVAL\_TEMP\_VIOLATION & 0x20 & Violación temperatura \\
EVENT\_HWVAL\_VOLTAGE\_GLITCH & 0x21 & Glitch de voltaje \\
EVENT\_HWVAL\_CLOCK\_ANOMALY & 0x22 & Anomalía de reloj \\
EVENT\_HWVAL\_MEM\_CORRUPT & 0x23 & Memoria corrompida \\
EVENT\_HWVAL\_FLASH\_TAMPER & 0x24 & Flash alterado \\

\caption{Constantes de configuración de NanOS/NERT}
\label{tab:constants}
\end{longtable}

\chapter{Glosario}

\begin{description}[style=nextline]
    \item[AIS (v0.6)] Artificial Immune System. Sistema Inmune Artificial basado
        en el algoritmo de Selección Negativa. Detecta anomalías sin necesidad
        de firmas de ataques conocidos. ``El sistema inmune no necesita saber
        cómo se ven los ataques --- solo qué aspecto tiene `saludable'.''

    \item[Apoptosis] Muerte celular programada. En NanOS, el proceso por el
        cual un nodo termina su ejecución de forma controlada.

    \item[Black Box (v0.5)] Sistema de preservación de evidencia forense.
        Los nodos emiten un ``testamento'' antes de morir que sobrevive en
        vecinos de confianza.

    \item[Bloom Filter] Estructura de datos probabilística para pruebas de
        membresía con eficiencia de espacio.

    \item[Canal Encubierto (v0.7)] Covert Channel. Comunicación física a través
        de side-channels como LEDs (óptico) o buzzers (acústico) para entornos
        air-gapped donde la red tradicional no está disponible.

    \item[Época (Epoch)] Período de tiempo durante el cual una clave de
        sesión es válida (por defecto: 1 hora).

    \item[FEC] Forward Error Correction. Técnica para recuperar datos
        perdidos sin retransmisión.

    \item[Gradiente] Campo escalar que indica la distancia a la reina,
        usado para enrutamiento.

    \item[Genetic Tuning (v0.7)] Sintonización Genética. Sistema de auto-optimización
        de parámetros NERT mediante algoritmos genéticos. La Queen mantiene una
        población de genomas y los distribuye a sub-swarms para evaluación comparativa.

    \item[Genome (v0.7)] Estructura de 32 bytes que codifica parámetros optimizables
        de NERT como genes evolucionables (timing, gossip, seguridad).

    \item[Gossip Protocol] Protocolo de diseminación epidémica de información.

    \item[Grace Window] Período en límites de época donde se aceptan
        claves de épocas adyacentes.

    \item[Hardware Validation (v0.6)] ``El Centinela del Silicio''. Sistema de
        monitoreo continuo de integridad del hardware para detectar manipulación
        física, sensores comprometidos, y ataques de fault injection. Valida
        temperatura, voltaje, frecuencia de reloj, y memoria. ``El hardware no
        puede mentir - pero puede ser torturado para dar falsas confesiones.''

    \item[HMAC] Hash-based Message Authentication Code.

    \item[Judas Node (v0.7)] Nodo Judas. Honeypot activo que, al detectar intrusión,
        finge vulnerabilidad para capturar payloads de atacantes antes de
        autodestruirse. Transmite evidencia forense a la Queen antes de la apoptosis.

    \item[LTD] Long-Term Depression. Debilitamiento de conexiones sinápticas
        tras eventos negativos (timeouts, fallos de entrega).

    \item[LTP] Long-Term Potentiation. Fortalecimiento de conexiones sinápticas
        tras eventos positivos (ACKs exitosos).

    \item[Manchester Encoding (v0.7)] Codificación donde cada bit se representa
        mediante una transición en mitad del período. Proporciona auto-sincronización
        para canales encubiertos ópticos.

    \item[Nodo Desechable] Nodo diseñado con vida útil limitada que
        regenera al morir.

    \item[NERT] NanOS Ephemeral Reliable Transport.

    \item[Pheromone] Mensaje de comunicación entre nodos del enjambre.

    \item[Polimorfismo de Código (v0.6)] ``El Camaleón''. Sistema de diversidad
        binaria que hace único a cada nodo. Incluye ASLR (randomización de
        memoria), Stack Canaries (detección de overflow), y Binary Signatures
        (huella digital única). ``Si un atacante compromete un nodo, ha ganado
        una batalla. Para comprometer el swarm, tendría que ganar miles diferentes.''

    \item[SACK] Selective Acknowledgment.

    \item[STDP] Spike-Timing Dependent Plasticity. Mecanismo donde el tiempo
        de respuesta afecta el aprendizaje (respuestas rápidas refuerzan más).

    \item[Stigmergia (v0.5)] Coordinación indirecta a través de modificación
        del ambiente. En NanOS, feromonas digitales que decaen con el tiempo
        y modifican costos de movimiento. ``Las hormigas no memorizan mapas.''

    \item[Sub-Swarm (v0.7)] Grupo de Workers que comparten el mismo genoma
        durante un período de evaluación. Permite A/B testing evolutivo de
        configuraciones NERT.

    \item[Swarm] Conjunto de nodos comunicándose colectivamente.

    \item[Synaptic Weight] Peso sináptico. Valor [1-255] que representa la
        confiabilidad aprendida de una conexión con un vecino.

    \item[Telemetry (v0.7)] Métricas de rendimiento (throughput, latency,
        reliability, security, survival) enviadas periódicamente por Workers
        a Queen para evaluar fitness de genomas.
\end{description}

%-------------------------------------------------------------------------------
% Back Matter
%-------------------------------------------------------------------------------

\backmatter

\chapter*{Sobre Este Documento}
\addcontentsline{toc}{chapter}{Sobre Este Documento}

Este manual técnico fue generado como parte del proyecto NanOS v0.7.
Cubre la arquitectura del sistema operativo, el protocolo NERT diseñado
específicamente para comunicación entre nodos desechables, el sistema
de enrutamiento Hebbiano inspirado en neurociencia, el sistema de feromonas
digitales Stigmergia, la Black Box distribuida para evidencia forense,
el Sistema Inmune Artificial (AIS) para detección de ataques 0-day,
el sistema de Polimorfismo de Código ``El Camaleón'' para diversidad binaria,
la Validación de Hardware ``El Centinela del Silicio'' para detección de
manipulación física, el sistema de Sintonización Genética para auto-optimización
evolutiva de parámetros NERT, los Nodos Judas como honeypots activos para
captura de inteligencia de amenazas, y los Canales Encubiertos para comunicación
física en entornos air-gapped.

\vspace{1cm}

\begin{center}
\begin{tikzpicture}
    \node[draw, rounded corners, fill=nanosprimary!10,
          minimum width=8cm, minimum height=2cm] {
        \begin{tabular}{c}
            \textbf{NanOS Project}\\
            \small Los nodos mueren, el enjambre vive.\\
            \small 2026
        \end{tabular}
    };
\end{tikzpicture}
\end{center}

\end{document}
